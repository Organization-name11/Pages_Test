{"version":3,"file":"index.umd.js","sources":["../../ouranos-gex-lib-for-JavaScript/src/zfxy.ts","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/helpers/dist/es/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/meta/dist/es/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/bbox/dist/es/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/invariant/dist/es/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/boolean-point-in-polygon/dist/es/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/line-segment/dist/es/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/rbush/rbush.min.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/helpers/dist/js/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/meta/dist/js/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/bbox/dist/js/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/geojson-rbush/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/line-intersect/dist/es/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/polygon-to-line/dist/es/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/boolean-disjoint/dist/es/index.js","../../ouranos-gex-lib-for-JavaScript/node_modules/@turf/boolean-intersects/dist/es/index.js","../../ouranos-gex-lib-for-JavaScript/src/tilebelt.ts","../../ouranos-gex-lib-for-JavaScript/src/index.ts","../../ouranos-gex-lib-for-JavaScript/src/zfxy_tilehash.ts"],"sourcesContent":["import { LngLat, LngLatWithAltitude } from \"./types\";\r\n\r\nexport type ZFXYTile = { z: number, f: number, x: number, y: number };\r\n\r\nexport function isZFXYTile(tile: any): tile is ZFXYTile {\r\n  return ('z' in tile && 'f' in tile && 'x' in tile && 'y' in tile);\r\n}\r\n\r\nexport const ZFXY_1M_ZOOM_BASE = 25 as const;\r\nexport const ZFXY_ROOT_TILE: ZFXYTile = { f: 0, x: 0, y: 0, z: 0 };\r\n\r\nconst rad2deg = 180 / Math.PI;\r\n\r\nexport function getParent(tile: ZFXYTile, steps: number = 1): ZFXYTile {\r\n  const { f,x,y,z } = tile;\r\n  if (steps <= 0) {\r\n    throw new Error('steps must be greater than 0');\r\n  }\r\n  if (steps > z) {\r\n    throw new Error(`Getting parent tile of ${tile}, ${steps} steps is not possible because it would go beyond the root tile (z=0)`);\r\n  }\r\n  return {\r\n    f: f >> steps,\r\n    x: x >> steps,\r\n    y: y >> steps,\r\n    z: z -  steps,\r\n  };\r\n}\r\n\r\nexport function getChildren(tile: ZFXYTile = ZFXY_ROOT_TILE): ZFXYTile[] {\r\n  const {f,x,y,z} = tile;\r\n  return [\r\n    {f: f * 2,     x: x * 2,     y: y * 2,     z: z+1}, // f +0, x +0, y +0\r\n    {f: f * 2,     x: x * 2 + 1, y: y * 2,     z: z+1}, // f +0, x +1, y +0\r\n    {f: f * 2,     x: x * 2,     y: y * 2 + 1, z: z+1}, // f +0, x +0, y +1\r\n    {f: f * 2,     x: x * 2 + 1, y: y * 2 + 1, z: z+1}, // f +0, x +1, y +1\r\n    {f: f * 2 + 1, x: x * 2,     y: y * 2,     z: z+1}, // f +1, x +0, y +0\r\n    {f: f * 2 + 1, x: x * 2 + 1, y: y * 2,     z: z+1}, // f +1, x +1, y +0\r\n    {f: f * 2 + 1, x: x * 2,     y: y * 2 + 1, z: z+1}, // f +1, x +0, y +1\r\n    {f: f * 2 + 1, x: x * 2 + 1, y: y * 2 + 1, z: z+1}, // f +1, x +1, y +1\r\n  ];\r\n}\r\n\r\nexport function getSurrounding(tile: ZFXYTile = ZFXY_ROOT_TILE): ZFXYTile[] {\r\n  const {f,x,y,z} = tile;\r\n  return [\r\n    zfxyWraparound({f: f, x: x,     y: y,     z: z}), // f +0, x +0, y +0\r\n    zfxyWraparound({f: f, x: x + 1, y: y,     z: z}), // f +0, x +1, y +0\r\n    zfxyWraparound({f: f, x: x,     y: y + 1, z: z}), // f +0, x +0, y +1\r\n    zfxyWraparound({f: f, x: x + 1, y: y + 1, z: z}), // f +0, x +1, y +1\r\n    zfxyWraparound({f: f, x: x - 1, y: y,     z: z}), // f +0, x -1, y +0\r\n    zfxyWraparound({f: f, x: x,     y: y - 1, z: z}), // f +0, x +0, y -1\r\n    zfxyWraparound({f: f, x: x - 1, y: y - 1, z: z}), // f +0, x -1, y -1\r\n    zfxyWraparound({f: f, x: x + 1, y: y - 1, z: z}), // f +0, x +1, y -1\r\n    zfxyWraparound({f: f, x: x - 1, y: y + 1, z: z}), // f +0, x -1, y +1\r\n  ];\r\n}\r\n\r\nexport function parseZFXYString(str: string): ZFXYTile | undefined {\r\n  const match = str.match(/^\\/?(\\d+)\\/(?:(\\d+)\\/)?(\\d+)\\/(\\d+)$/);\r\n  if (!match) {\r\n    return undefined;\r\n  }\r\n  return {\r\n    z: parseInt(match[1], 10),\r\n    f: parseInt(match[2] || '0', 10),\r\n    x: parseInt(match[3], 10),\r\n    y: parseInt(match[4], 10),\r\n  };\r\n}\r\n\r\n/** Returns the lng,lat of the northwest corner of the provided tile */\r\nexport function getLngLat(tile: ZFXYTile): LngLat {\r\n  const n = Math.PI - 2 * Math.PI * tile.y / Math.pow(2, tile.z);\r\n  return {\r\n    lng: tile.x / Math.pow(2, tile.z) * 360 - 180,\r\n    lat: rad2deg * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))),\r\n  };\r\n}\r\n\r\nexport function getCenterLngLat(tile: ZFXYTile): LngLat {\r\n  const x = tile.x * 2 + 1,\r\n        y = tile.y * 2 + 1,\r\n        z = tile.z + 1;\r\n  return getLngLat({x, y, z, f: 0});\r\n}\r\n\r\nexport function getCenterLngLatAlt(tile: ZFXYTile): LngLatWithAltitude {\r\n  return {\r\n    ...getCenterLngLat(tile),\r\n    alt: getFloor(tile) + ((2**ZFXY_1M_ZOOM_BASE) / (2**(tile.z + 1))),\r\n  };\r\n}\r\n\r\nexport function getBBox(tile: ZFXYTile): [LngLat, LngLat] {\r\n  const nw = getLngLat(tile),\r\n        se = getLngLat({...tile, y: tile.y + 1, x: tile.x + 1});\r\n  return [ nw, se ];\r\n}\r\n\r\n/** Returns the floor of the voxel, in meters */\r\nexport function getFloor(tile: ZFXYTile): number {\r\n  return tile.f * (2**ZFXY_1M_ZOOM_BASE) / (2**tile.z)\r\n}\r\n\r\nexport interface CalculateZFXYInput {\r\n  lat: number\r\n  lng: number\r\n  alt?: number\r\n  zoom: number\r\n}\r\n\r\nexport function calculateZFXY(input: CalculateZFXYInput): ZFXYTile {\r\n  const meters = typeof input.alt !== 'undefined' ? input.alt : 0;\r\n  if (meters <= -(2**ZFXY_1M_ZOOM_BASE) || meters >= (2**ZFXY_1M_ZOOM_BASE)) {\r\n    // TODO: make altitude unlimited?\r\n    throw new Error(`ZFXY only supports altitude between -2^${ZFXY_1M_ZOOM_BASE} and +2^${ZFXY_1M_ZOOM_BASE}.`);\r\n  }\r\n  const f = Math.floor(((2 ** input.zoom) * meters) / (2 ** ZFXY_1M_ZOOM_BASE));\r\n\r\n  // Algorithm adapted from tilebelt.js\r\n  const d2r = Math.PI / 180;\r\n  const sin = Math.sin(input.lat * d2r);\r\n  const z2 = 2 ** input.zoom;\r\n  let x = z2 * (input.lng / 360 + 0.5);\r\n  const y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\r\n\r\n  // Wrap Tile X\r\n  x = x % z2;\r\n  if (x < 0) x = x + z2;\r\n\r\n  return {\r\n    f: f,\r\n    x: Math.floor(x),\r\n    y: Math.floor(y),\r\n    z: input.zoom,\r\n  };\r\n}\r\n\r\n/**\r\n * Fix a tile that has out-of-bounds coordinates by:\r\n * for the x and y coordinates: wrapping the coordinates around.\r\n * for the f coordinate: limiting to maximum or minimum.\r\n */\r\nexport function zfxyWraparound(tile: ZFXYTile): ZFXYTile {\r\n  const {z, f, x, y} = tile;\r\n  return {\r\n    z,\r\n    f: Math.max(Math.min(f, (2**z)), -(2**z)),\r\n    x: (x < 0) ? x + 2**z : x % 2**z,\r\n    y: (y < 0) ? y + 2**z : y % 2**z,\r\n  }\r\n}\r\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import { coordEach } from \"@turf/meta\";\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexport default bbox;\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord, getGeom } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nexport default function booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = getCoord(point);\n    var geom = getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] &&\n        ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 &&\n            (xi - pt[0]) * (xj - pt[0]) <= 0 &&\n            (yi - pt[1]) * (yj - pt[1]) <= 0;\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = yi > pt[1] !== yj > pt[1] &&\n            pt[0] < ((xj - xi) * (pt[1] - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return (bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1]);\n}\n","import { featureCollection, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = x1 < x2 ? x1 : x2;\n    var south = y1 < y2 ? y1 : y2;\n    var east = x1 > x2 ? x1 : x2;\n    var north = y1 > y2 ? y1 : y2;\n    return [west, south, east, north];\n}\nexport default lineSegment;\n","!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=t||self).RBush=i()}(this,function(){\"use strict\";function t(t,r,e,a,h){!function t(n,r,e,a,h){for(;a>e;){if(a-e>600){var o=a-e+1,s=r-e+1,l=Math.log(o),f=.5*Math.exp(2*l/3),u=.5*Math.sqrt(l*f*(o-f)/o)*(s-o/2<0?-1:1),m=Math.max(e,Math.floor(r-s*f/o+u)),c=Math.min(a,Math.floor(r+(o-s)*f/o+u));t(n,r,m,c,h)}var p=n[r],d=e,x=a;for(i(n,e,r),h(n[a],p)>0&&i(n,e,a);d<x;){for(i(n,d,x),d++,x--;h(n[d],p)<0;)d++;for(;h(n[x],p)>0;)x--}0===h(n[e],p)?i(n,e,x):i(n,++x,a),x<=r&&(e=x+1),r<=x&&(a=x-1)}}(t,r,e||0,a||t.length-1,h||n)}function i(t,i,n){var r=t[i];t[i]=t[n],t[n]=r}function n(t,i){return t<i?-1:t>i?1:0}var r=function(t){void 0===t&&(t=9),this._maxEntries=Math.max(4,t),this._minEntries=Math.max(2,Math.ceil(.4*this._maxEntries)),this.clear()};function e(t,i,n){if(!n)return i.indexOf(t);for(var r=0;r<i.length;r++)if(n(t,i[r]))return r;return-1}function a(t,i){h(t,0,t.children.length,i,t)}function h(t,i,n,r,e){e||(e=p(null)),e.minX=1/0,e.minY=1/0,e.maxX=-1/0,e.maxY=-1/0;for(var a=i;a<n;a++){var h=t.children[a];o(e,t.leaf?r(h):h)}return e}function o(t,i){return t.minX=Math.min(t.minX,i.minX),t.minY=Math.min(t.minY,i.minY),t.maxX=Math.max(t.maxX,i.maxX),t.maxY=Math.max(t.maxY,i.maxY),t}function s(t,i){return t.minX-i.minX}function l(t,i){return t.minY-i.minY}function f(t){return(t.maxX-t.minX)*(t.maxY-t.minY)}function u(t){return t.maxX-t.minX+(t.maxY-t.minY)}function m(t,i){return t.minX<=i.minX&&t.minY<=i.minY&&i.maxX<=t.maxX&&i.maxY<=t.maxY}function c(t,i){return i.minX<=t.maxX&&i.minY<=t.maxY&&i.maxX>=t.minX&&i.maxY>=t.minY}function p(t){return{children:t,height:1,leaf:!0,minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}}function d(i,n,r,e,a){for(var h=[n,r];h.length;)if(!((r=h.pop())-(n=h.pop())<=e)){var o=n+Math.ceil((r-n)/e/2)*e;t(i,o,n,r,a),h.push(n,o,o,r)}}return r.prototype.all=function(){return this._all(this.data,[])},r.prototype.search=function(t){var i=this.data,n=[];if(!c(t,i))return n;for(var r=this.toBBox,e=[];i;){for(var a=0;a<i.children.length;a++){var h=i.children[a],o=i.leaf?r(h):h;c(t,o)&&(i.leaf?n.push(h):m(t,o)?this._all(h,n):e.push(h))}i=e.pop()}return n},r.prototype.collides=function(t){var i=this.data;if(!c(t,i))return!1;for(var n=[];i;){for(var r=0;r<i.children.length;r++){var e=i.children[r],a=i.leaf?this.toBBox(e):e;if(c(t,a)){if(i.leaf||m(t,a))return!0;n.push(e)}}i=n.pop()}return!1},r.prototype.load=function(t){if(!t||!t.length)return this;if(t.length<this._minEntries){for(var i=0;i<t.length;i++)this.insert(t[i]);return this}var n=this._build(t.slice(),0,t.length-1,0);if(this.data.children.length)if(this.data.height===n.height)this._splitRoot(this.data,n);else{if(this.data.height<n.height){var r=this.data;this.data=n,n=r}this._insert(n,this.data.height-n.height-1,!0)}else this.data=n;return this},r.prototype.insert=function(t){return t&&this._insert(t,this.data.height-1),this},r.prototype.clear=function(){return this.data=p([]),this},r.prototype.remove=function(t,i){if(!t)return this;for(var n,r,a,h=this.data,o=this.toBBox(t),s=[],l=[];h||s.length;){if(h||(h=s.pop(),r=s[s.length-1],n=l.pop(),a=!0),h.leaf){var f=e(t,h.children,i);if(-1!==f)return h.children.splice(f,1),s.push(h),this._condense(s),this}a||h.leaf||!m(h,o)?r?(n++,h=r.children[n],a=!1):h=null:(s.push(h),l.push(n),n=0,r=h,h=h.children[0])}return this},r.prototype.toBBox=function(t){return t},r.prototype.compareMinX=function(t,i){return t.minX-i.minX},r.prototype.compareMinY=function(t,i){return t.minY-i.minY},r.prototype.toJSON=function(){return this.data},r.prototype.fromJSON=function(t){return this.data=t,this},r.prototype._all=function(t,i){for(var n=[];t;)t.leaf?i.push.apply(i,t.children):n.push.apply(n,t.children),t=n.pop();return i},r.prototype._build=function(t,i,n,r){var e,h=n-i+1,o=this._maxEntries;if(h<=o)return a(e=p(t.slice(i,n+1)),this.toBBox),e;r||(r=Math.ceil(Math.log(h)/Math.log(o)),o=Math.ceil(h/Math.pow(o,r-1))),(e=p([])).leaf=!1,e.height=r;var s=Math.ceil(h/o),l=s*Math.ceil(Math.sqrt(o));d(t,i,n,l,this.compareMinX);for(var f=i;f<=n;f+=l){var u=Math.min(f+l-1,n);d(t,f,u,s,this.compareMinY);for(var m=f;m<=u;m+=s){var c=Math.min(m+s-1,u);e.children.push(this._build(t,m,c,r-1))}}return a(e,this.toBBox),e},r.prototype._chooseSubtree=function(t,i,n,r){for(;r.push(i),!i.leaf&&r.length-1!==n;){for(var e=1/0,a=1/0,h=void 0,o=0;o<i.children.length;o++){var s=i.children[o],l=f(s),u=(m=t,c=s,(Math.max(c.maxX,m.maxX)-Math.min(c.minX,m.minX))*(Math.max(c.maxY,m.maxY)-Math.min(c.minY,m.minY))-l);u<a?(a=u,e=l<e?l:e,h=s):u===a&&l<e&&(e=l,h=s)}i=h||i.children[0]}var m,c;return i},r.prototype._insert=function(t,i,n){var r=n?t:this.toBBox(t),e=[],a=this._chooseSubtree(r,this.data,i,e);for(a.children.push(t),o(a,r);i>=0&&e[i].children.length>this._maxEntries;)this._split(e,i),i--;this._adjustParentBBoxes(r,e,i)},r.prototype._split=function(t,i){var n=t[i],r=n.children.length,e=this._minEntries;this._chooseSplitAxis(n,e,r);var h=this._chooseSplitIndex(n,e,r),o=p(n.children.splice(h,n.children.length-h));o.height=n.height,o.leaf=n.leaf,a(n,this.toBBox),a(o,this.toBBox),i?t[i-1].children.push(o):this._splitRoot(n,o)},r.prototype._splitRoot=function(t,i){this.data=p([t,i]),this.data.height=t.height+1,this.data.leaf=!1,a(this.data,this.toBBox)},r.prototype._chooseSplitIndex=function(t,i,n){for(var r,e,a,o,s,l,u,m=1/0,c=1/0,p=i;p<=n-i;p++){var d=h(t,0,p,this.toBBox),x=h(t,p,n,this.toBBox),v=(e=d,a=x,o=void 0,s=void 0,l=void 0,u=void 0,o=Math.max(e.minX,a.minX),s=Math.max(e.minY,a.minY),l=Math.min(e.maxX,a.maxX),u=Math.min(e.maxY,a.maxY),Math.max(0,l-o)*Math.max(0,u-s)),M=f(d)+f(x);v<m?(m=v,r=p,c=M<c?M:c):v===m&&M<c&&(c=M,r=p)}return r||n-i},r.prototype._chooseSplitAxis=function(t,i,n){var r=t.leaf?this.compareMinX:s,e=t.leaf?this.compareMinY:l;this._allDistMargin(t,i,n,r)<this._allDistMargin(t,i,n,e)&&t.children.sort(r)},r.prototype._allDistMargin=function(t,i,n,r){t.children.sort(r);for(var e=this.toBBox,a=h(t,0,i,e),s=h(t,n-i,n,e),l=u(a)+u(s),f=i;f<n-i;f++){var m=t.children[f];o(a,t.leaf?e(m):m),l+=u(a)}for(var c=n-i-1;c>=i;c--){var p=t.children[c];o(s,t.leaf?e(p):p),l+=u(s)}return l},r.prototype._adjustParentBBoxes=function(t,i,n){for(var r=n;r>=0;r--)o(i[r],t)},r.prototype._condense=function(t){for(var i=t.length-1,n=void 0;i>=0;i--)0===t[i].children.length?i>0?(n=t[i-1].children).splice(n.indexOf(t[i]),1):this.clear():a(t[i],this.toBBox)},r});\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.37,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return !!input && input.constructor === Object;\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            helpers.feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = helpers.lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              helpers.lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return helpers.lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return helpers.lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return helpers.point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return helpers.point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return helpers.point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return helpers.point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexports.coordAll = coordAll;\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.findPoint = findPoint;\nexports.findSegment = findSegment;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexports.default = bbox;\n","var rbush = require('rbush');\nvar helpers = require('@turf/helpers');\nvar meta = require('@turf/meta');\nvar turfBBox = require('@turf/bbox').default;\nvar featureEach = meta.featureEach;\nvar coordEach = meta.coordEach;\nvar polygon = helpers.polygon;\nvar featureCollection = helpers.featureCollection;\n\n/**\n * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.\n *\n * @name rbush\n * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a\n * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.\n * @returns {RBush} GeoJSON RBush\n * @example\n * var geojsonRbush = require('geojson-rbush').default;\n * var tree = geojsonRbush();\n */\nfunction geojsonRbush(maxEntries) {\n    var tree = new rbush(maxEntries);\n    /**\n     * [insert](https://github.com/mourner/rbush#data-format)\n     *\n     * @param {Feature} feature insert single GeoJSON Feature\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     * tree.insert(poly)\n     */\n    tree.insert = function (feature) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.insert.call(this, feature);\n    };\n\n    /**\n     * [load](https://github.com/mourner/rbush#bulk-inserting-data)\n     *\n     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var polys = turf.polygons([\n     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],\n     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]\n     * ]);\n     * tree.load(polys);\n     */\n    tree.load = function (features) {\n        var load = [];\n        // Load an Array of Features\n        if (Array.isArray(features)) {\n            features.forEach(function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        } else {\n            // Load a FeatureCollection\n            featureEach(features, function (feature) {\n                if (feature.type !== 'Feature') throw new Error('invalid features');\n                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n                load.push(feature);\n            });\n        }\n        return rbush.prototype.load.call(this, load);\n    };\n\n    /**\n     * [remove](https://github.com/mourner/rbush#removing-data)\n     *\n     * @param {Feature} feature remove single GeoJSON Feature\n     * @param {Function} equals Pass a custom equals function to compare by value for removal.\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.remove(poly);\n     */\n    tree.remove = function (feature, equals) {\n        if (feature.type !== 'Feature') throw new Error('invalid feature');\n        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);\n        return rbush.prototype.remove.call(this, feature, equals);\n    };\n\n    /**\n     * [clear](https://github.com/mourner/rbush#removing-data)\n     *\n     * @returns {RBush} GeoJSON Rbush\n     * @example\n     * tree.clear()\n     */\n    tree.clear = function () {\n        return rbush.prototype.clear.call(this);\n    };\n\n    /**\n     * [search](https://github.com/mourner/rbush#search)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON\n     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.search(poly);\n     */\n    tree.search = function (geojson) {\n        var features = rbush.prototype.search.call(this, this.toBBox(geojson));\n        return featureCollection(features);\n    };\n\n    /**\n     * [collides](https://github.com/mourner/rbush#collisions)\n     *\n     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON\n     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.\n     * @example\n     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);\n     *\n     * tree.collides(poly);\n     */\n    tree.collides = function (geojson) {\n        return rbush.prototype.collides.call(this, this.toBBox(geojson));\n    };\n\n    /**\n     * [all](https://github.com/mourner/rbush#search)\n     *\n     * @returns {FeatureCollection} all the features in RBush\n     * @example\n     * tree.all()\n     */\n    tree.all = function () {\n        var features = rbush.prototype.all.call(this);\n        return featureCollection(features);\n    };\n\n    /**\n     * [toJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @returns {any} export data as JSON object\n     * @example\n     * var exported = tree.toJSON()\n     */\n    tree.toJSON = function () {\n        return rbush.prototype.toJSON.call(this);\n    };\n\n    /**\n     * [fromJSON](https://github.com/mourner/rbush#export-and-import)\n     *\n     * @param {any} json import previously exported data\n     * @returns {RBush} GeoJSON RBush\n     * @example\n     * var exported = {\n     *   \"children\": [\n     *     {\n     *       \"type\": \"Feature\",\n     *       \"geometry\": {\n     *         \"type\": \"Point\",\n     *         \"coordinates\": [110, 50]\n     *       },\n     *       \"properties\": {},\n     *       \"bbox\": [110, 50, 110, 50]\n     *     }\n     *   ],\n     *   \"height\": 1,\n     *   \"leaf\": true,\n     *   \"minX\": 110,\n     *   \"minY\": 50,\n     *   \"maxX\": 110,\n     *   \"maxY\": 50\n     * }\n     * tree.fromJSON(exported)\n     */\n    tree.fromJSON = function (json) {\n        return rbush.prototype.fromJSON.call(this, json);\n    };\n\n    /**\n     * Converts GeoJSON to {minX, minY, maxX, maxY} schema\n     *\n     * @private\n     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from\n     * @returns {Object} converted to {minX, minY, maxX, maxY}\n     */\n    tree.toBBox = function (geojson) {\n        var bbox;\n        if (geojson.bbox) bbox = geojson.bbox;\n        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;\n        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];\n        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);\n        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);\n        else throw new Error('invalid geojson')\n\n        return {\n            minX: bbox[0],\n            minY: bbox[1],\n            maxX: bbox[2],\n            maxY: bbox[3]\n        };\n    };\n    return tree;\n}\n\nmodule.exports = geojsonRbush;\nmodule.exports.default = geojsonRbush;\n","import { feature, featureCollection, point, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport lineSegment from \"@turf/line-segment\";\nimport { featureEach } from \"@turf/meta\";\nimport rbush from \"geojson-rbush\";\n/**\n * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).\n *\n * @name lineIntersect\n * @param {GeoJSON} line1 any LineString or Polygon\n * @param {GeoJSON} line2 any LineString or Polygon\n * @returns {FeatureCollection<Point>} point(s) that intersect both\n * @example\n * var line1 = turf.lineString([[126, -11], [129, -21]]);\n * var line2 = turf.lineString([[123, -18], [131, -14]]);\n * var intersects = turf.lineIntersect(line1, line2);\n *\n * //addToMap\n * var addToMap = [line1, line2, intersects]\n */\nfunction lineIntersect(line1, line2) {\n    var unique = {};\n    var results = [];\n    // First, normalize geometries to features\n    // Then, handle simple 2-vertex segments\n    if (line1.type === \"LineString\") {\n        line1 = feature(line1);\n    }\n    if (line2.type === \"LineString\") {\n        line2 = feature(line2);\n    }\n    if (line1.type === \"Feature\" &&\n        line2.type === \"Feature\" &&\n        line1.geometry !== null &&\n        line2.geometry !== null &&\n        line1.geometry.type === \"LineString\" &&\n        line2.geometry.type === \"LineString\" &&\n        line1.geometry.coordinates.length === 2 &&\n        line2.geometry.coordinates.length === 2) {\n        var intersect = intersects(line1, line2);\n        if (intersect) {\n            results.push(intersect);\n        }\n        return featureCollection(results);\n    }\n    // Handles complex GeoJSON Geometries\n    var tree = rbush();\n    tree.load(lineSegment(line2));\n    featureEach(lineSegment(line1), function (segment) {\n        featureEach(tree.search(segment), function (match) {\n            var intersect = intersects(segment, match);\n            if (intersect) {\n                // prevent duplicate points https://github.com/Turfjs/turf/issues/688\n                var key = getCoords(intersect).join(\",\");\n                if (!unique[key]) {\n                    unique[key] = true;\n                    results.push(intersect);\n                }\n            }\n        });\n    });\n    return featureCollection(results);\n}\n/**\n * Find a point that intersects LineStrings with two coordinates each\n *\n * @private\n * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)\n * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)\n * @returns {Feature<Point>} intersecting GeoJSON Point\n */\nfunction intersects(line1, line2) {\n    var coords1 = getCoords(line1);\n    var coords2 = getCoords(line2);\n    if (coords1.length !== 2) {\n        throw new Error(\"<intersects> line1 must only contain 2 coordinates\");\n    }\n    if (coords2.length !== 2) {\n        throw new Error(\"<intersects> line2 must only contain 2 coordinates\");\n    }\n    var x1 = coords1[0][0];\n    var y1 = coords1[0][1];\n    var x2 = coords1[1][0];\n    var y2 = coords1[1][1];\n    var x3 = coords2[0][0];\n    var y3 = coords2[0][1];\n    var x4 = coords2[1][0];\n    var y4 = coords2[1][1];\n    var denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);\n    var numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);\n    if (denom === 0) {\n        if (numeA === 0 && numeB === 0) {\n            return null;\n        }\n        return null;\n    }\n    var uA = numeA / denom;\n    var uB = numeB / denom;\n    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n        var x = x1 + uA * (x2 - x1);\n        var y = y1 + uA * (y2 - y1);\n        return point([x, y]);\n    }\n    return null;\n}\nexport default lineIntersect;\n","import { featureCollection, lineString, multiLineString } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Converts a {@link Polygon} to {@link LineString|(Multi)LineString} or {@link MultiPolygon} to a\n * {@link FeatureCollection} of {@link LineString|(Multi)LineString}.\n *\n * @name polygonToLine\n * @param {Feature<Polygon|MultiPolygon>} poly Feature to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @returns {FeatureCollection|Feature<LineString|MultiLinestring>} converted (Multi)Polygon to (Multi)LineString\n * @example\n * var poly = turf.polygon([[[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]]);\n *\n * var line = turf.polygonToLine(poly);\n *\n * //addToMap\n * var addToMap = [line];\n */\nexport default function (poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    if (!options.properties && poly.type === \"Feature\") {\n        options.properties = poly.properties;\n    }\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonToLine(geom, options);\n        case \"MultiPolygon\":\n            return multiPolygonToLine(geom, options);\n        default:\n            throw new Error(\"invalid poly\");\n    }\n}\n/**\n * @private\n */\nexport function polygonToLine(poly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(poly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : poly.type === \"Feature\"\n            ? poly.properties\n            : {};\n    return coordsToLine(coords, properties);\n}\n/**\n * @private\n */\nexport function multiPolygonToLine(multiPoly, options) {\n    if (options === void 0) { options = {}; }\n    var geom = getGeom(multiPoly);\n    var coords = geom.coordinates;\n    var properties = options.properties\n        ? options.properties\n        : multiPoly.type === \"Feature\"\n            ? multiPoly.properties\n            : {};\n    var lines = [];\n    coords.forEach(function (coord) {\n        lines.push(coordsToLine(coord, properties));\n    });\n    return featureCollection(lines);\n}\n/**\n * @private\n */\nexport function coordsToLine(coords, properties) {\n    if (coords.length > 1) {\n        return multiLineString(coords, properties);\n    }\n    return lineString(coords[0], properties);\n}\n","import booleanPointInPolygon from \"@turf/boolean-point-in-polygon\";\nimport lineIntersect from \"@turf/line-intersect\";\nimport { flattenEach } from \"@turf/meta\";\nimport polygonToLine from \"@turf/polygon-to-line\";\n/**\n * Boolean-disjoint returns (TRUE) if the intersection of the two geometries is an empty set.\n *\n * @name booleanDisjoint\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanDisjoint(line, point);\n * //=true\n */\nfunction booleanDisjoint(feature1, feature2) {\n    var bool = true;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === false) {\n                return false;\n            }\n            bool = disjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n/**\n * Disjoint operation for simple Geometries (Point/LineString/Polygon)\n *\n * @private\n * @param {Geometry<any>} geom1 GeoJSON Geometry\n * @param {Geometry<any>} geom2 GeoJSON Geometry\n * @returns {boolean} true/false\n */\nfunction disjoint(geom1, geom2) {\n    switch (geom1.type) {\n        case \"Point\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !compareCoords(geom1.coordinates, geom2.coordinates);\n                case \"LineString\":\n                    return !isPointOnLine(geom2, geom1);\n                case \"Polygon\":\n                    return !booleanPointInPolygon(geom1, geom2);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"LineString\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !isPointOnLine(geom1, geom2);\n                case \"LineString\":\n                    return !isLineOnLine(geom1, geom2);\n                case \"Polygon\":\n                    return !isLineInPoly(geom2, geom1);\n            }\n            /* istanbul ignore next */\n            break;\n        case \"Polygon\":\n            switch (geom2.type) {\n                case \"Point\":\n                    return !booleanPointInPolygon(geom2, geom1);\n                case \"LineString\":\n                    return !isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return !isPolyInPoly(geom2, geom1);\n            }\n    }\n    return false;\n}\n// http://stackoverflow.com/a/11908158/1979085\nfunction isPointOnLine(lineString, pt) {\n    for (var i = 0; i < lineString.coordinates.length - 1; i++) {\n        if (isPointOnLineSegment(lineString.coordinates[i], lineString.coordinates[i + 1], pt.coordinates)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isLineOnLine(lineString1, lineString2) {\n    var doLinesIntersect = lineIntersect(lineString1, lineString2);\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isLineInPoly(polygon, lineString) {\n    for (var _i = 0, _a = lineString.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (booleanPointInPolygon(coord, polygon)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(lineString, polygonToLine(polygon));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\n/**\n * Is Polygon (geom1) in Polygon (geom2)\n * Only takes into account outer rings\n * See http://stackoverflow.com/a/4833823/1979085\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    for (var _i = 0, _a = feature1.coordinates[0]; _i < _a.length; _i++) {\n        var coord1 = _a[_i];\n        if (booleanPointInPolygon(coord1, feature2)) {\n            return true;\n        }\n    }\n    for (var _b = 0, _c = feature2.coordinates[0]; _b < _c.length; _b++) {\n        var coord2 = _c[_b];\n        if (booleanPointInPolygon(coord2, feature1)) {\n            return true;\n        }\n    }\n    var doLinesIntersect = lineIntersect(polygonToLine(feature1), polygonToLine(feature2));\n    if (doLinesIntersect.features.length > 0) {\n        return true;\n    }\n    return false;\n}\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {\n    var dxc = pt[0] - lineSegmentStart[0];\n    var dyc = pt[1] - lineSegmentStart[1];\n    var dxl = lineSegmentEnd[0] - lineSegmentStart[0];\n    var dyl = lineSegmentEnd[1] - lineSegmentStart[1];\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (Math.abs(dxl) >= Math.abs(dyl)) {\n        if (dxl > 0) {\n            return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];\n        }\n        else {\n            return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];\n        }\n    }\n    else if (dyl > 0) {\n        return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];\n    }\n    else {\n        return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];\n    }\n}\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexport default booleanDisjoint;\n","import booleanDisjoint from \"@turf/boolean-disjoint\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Boolean-intersects returns (TRUE) two geometries intersect.\n *\n * @name booleanIntersects\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var point = turf.point([2, 2]);\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n *\n * turf.booleanIntersects(line, point);\n * //=true\n */\nexport default function booleanIntersects(feature1, feature2) {\n    var bool = false;\n    flattenEach(feature1, function (flatten1) {\n        flattenEach(feature2, function (flatten2) {\n            if (bool === true) {\n                return true;\n            }\n            bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry);\n        });\n    });\n    return bool;\n}\n","import { BBox } from \"geojson\";\r\n\r\nconst d2r = Math.PI / 180,\r\n      r2d = 180 / Math.PI,\r\n      MAX_ZOOM = 28;\r\n\r\nexport function getBboxZoom(bbox: BBox) {\r\n  for (let z = 0; z < MAX_ZOOM; z++) {\r\n    const mask = 1 << (32 - (z + 1));\r\n    if (((bbox[0] & mask) !== (bbox[2] & mask)) ||\r\n        ((bbox[1] & mask) !== (bbox[3] & mask))) {\r\n      return z;\r\n    }\r\n  }\r\n\r\n  return MAX_ZOOM;\r\n}\r\n\r\n/**\r\n * Get the smallest tile to cover a bbox\r\n */\r\nexport function bboxToTile(bboxCoords: BBox, minZoom?: number): Array<number> {\r\n  const min = pointToTile(bboxCoords[0], bboxCoords[1], 32);\r\n  const max = pointToTile(bboxCoords[2], bboxCoords[3], 32);\r\n  const bbox: BBox = [min[0], min[1], max[0], max[1]];\r\n\r\n  const z = Math.min(getBboxZoom(bbox), typeof minZoom !== 'undefined' ? minZoom : MAX_ZOOM);\r\n  if (z === 0) return [0, 0, 0];\r\n  const x = bbox[0] >>> (32 - z);\r\n  const y = bbox[1] >>> (32 - z);\r\n  return [x, y, z];\r\n}\r\n\r\n/**\r\n * Get the tile for a point at a specified zoom level\r\n */\r\nexport function pointToTile(lon: number, lat: number, z: number) {\r\n  var tile = pointToTileFraction(lon, lat, z);\r\n  tile[0] = Math.floor(tile[0]);\r\n  tile[1] = Math.floor(tile[1]);\r\n  return tile;\r\n}\r\n\r\n/**\r\n * Get the precise fractional tile location for a point at a zoom level\r\n */\r\nfunction pointToTileFraction(lon: number, lat: number, z: number) {\r\n  var sin = Math.sin(lat * d2r),\r\n      z2 = Math.pow(2, z),\r\n      x = z2 * (lon / 360 + 0.5),\r\n      y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\r\n\r\n  // Wrap Tile X\r\n  x = x % z2;\r\n  if (x < 0) x = x + z2;\r\n  return [x, y, z];\r\n}\r\n","import { LngLatWithAltitude } from \"./types\";\r\nimport { calculateZFXY, getBBox, getChildren, getFloor, getParent, isZFXYTile, parseZFXYString, ZFXYTile, zfxyWraparound, getSurrounding, getCenterLngLatAlt } from \"./zfxy\";\r\nimport { generateTilehash, parseZFXYTilehash } from \"./zfxy_tilehash\";\r\nimport turfBBox from '@turf/bbox';\r\nimport turfBooleanIntersects from '@turf/boolean-intersects';\r\nimport type { Geometry, Polygon } from \"geojson\";\r\nimport { bboxToTile, pointToTile } from \"./tilebelt\";\r\n\r\nconst DEFAULT_ZOOM = 25 as const;\r\n\r\nexport class Space {\r\n  center: LngLatWithAltitude\r\n  alt: number\r\n  zoom: number\r\n\r\n  zfxy: ZFXYTile\r\n\r\n  id: string\r\n  zfxyStr: string\r\n  tilehash: string\r\n\r\n  /**\r\n   * Create a new Space\r\n   *\r\n   * @param input A LngLatWithAltitude or string containing either a ZFXY or tilehash-encoded ZFXY.\r\n   * @param zoom Optional. Defaults to 25 when `input` is LngLatWithAltitude. Ignored when ZXFY or tilehash is provided.\r\n   */\r\n  constructor(input: LngLatWithAltitude | ZFXYTile | string, zoom?: number) {\r\n    if (typeof input === 'string') {\r\n      // parse string\r\n      let zfxy = parseZFXYString(input) || parseZFXYTilehash(input);\r\n      if (zfxy) {\r\n        this.zfxy = zfxy;\r\n        this._regenerateAttributesFromZFXY();\r\n      } else {\r\n        throw new Error(`parse ZFXY failed with input: ${input}`);\r\n      }\r\n      return;\r\n    } else if (isZFXYTile(input)) {\r\n      this.zfxy = input;\r\n      this._regenerateAttributesFromZFXY();\r\n      return;\r\n    } else {\r\n      this.zfxy = calculateZFXY({\r\n        ...input,\r\n        zoom: (typeof zoom !== 'undefined') ? zoom : DEFAULT_ZOOM,\r\n      });\r\n    }\r\n\r\n    this._regenerateAttributesFromZFXY();\r\n  }\r\n\r\n  /* - PUBLIC API - */\r\n\r\n  up(by: number = 1) {\r\n    return this.move({f: by});\r\n  }\r\n\r\n  down(by: number = 1) {\r\n    return this.move({f: -by});\r\n  }\r\n\r\n  north(by: number = 1) {\r\n    return this.move({y: by});\r\n  }\r\n\r\n  south(by: number = 1) {\r\n    return this.move({y: -by});\r\n  }\r\n\r\n  east(by: number = 1) {\r\n    return this.move({x: by});\r\n  }\r\n\r\n  west(by: number = 1) {\r\n    return this.move({x: -by});\r\n  }\r\n\r\n  move(by: Partial<Omit<ZFXYTile, 'z'>>) {\r\n    const newSpace = new Space(this.zfxy);\r\n    newSpace.zfxy = zfxyWraparound({\r\n      z: newSpace.zfxy.z,\r\n      f: newSpace.zfxy.f + (by.f || 0),\r\n      x: newSpace.zfxy.x + (by.x || 0),\r\n      y: newSpace.zfxy.y + (by.y || 0),\r\n    });\r\n    newSpace._regenerateAttributesFromZFXY();\r\n    return newSpace;\r\n  }\r\n\r\n  parent(atZoom?: number) {\r\n    const steps = (typeof atZoom === 'undefined') ? 1 : this.zfxy.z - atZoom;\r\n    return new Space(getParent(this.zfxy, steps));\r\n  }\r\n\r\n  children() {\r\n    return getChildren(this.zfxy).map((tile) => new Space(tile));\r\n  }\r\n\r\n  /** Return an array of Space objects at the same zoom level that surround this Space\r\n   * object. This method does not return the Space object itself, so the array will\r\n   * contain 26 Space objects.\r\n   */\r\n  surroundings(): Space[] {\r\n    return [\r\n      ...(\r\n        getSurrounding(this.zfxy)\r\n        .filter(({z,f,x,y}) => `/${z}/${f}/${x}/${y}` !== this.zfxyStr)\r\n        .map((tile) => new Space(tile))\r\n      ),\r\n      ...(\r\n        getSurrounding(this.up().zfxy)\r\n        .map((tile) => new Space(tile))\r\n      ),\r\n      ...(\r\n        getSurrounding(this.down().zfxy)\r\n        .map((tile) => new Space(tile))\r\n      ),\r\n    ];\r\n  }\r\n\r\n  /** Returns true if a point lies within this Space. If the position's altitude is not\r\n   * specified, it is ignored from the calculation.\r\n   */\r\n  contains(position: LngLatWithAltitude) {\r\n    const geom = this.toGeoJSON();\r\n    const point = {\r\n      type: 'Point',\r\n      coordinates: [position.lng, position.lat],\r\n    };\r\n    const floor = this.alt;\r\n    const ceil = getFloor({...this.zfxy, f: this.zfxy.f + 1});\r\n    return (\r\n      turfBooleanIntersects(geom, point) &&\r\n      (typeof position.alt !== 'undefined' === true ?\r\n        position.alt >= floor && position.alt < ceil\r\n        :\r\n        true\r\n      )\r\n    );\r\n  }\r\n\r\n  /** Calculates the polygon of this Space and returns a 2D GeoJSON Polygon. */\r\n  toGeoJSON(): Polygon {\r\n    const [nw, se] = getBBox(this.zfxy);\r\n    return {\r\n      type: 'Polygon',\r\n      coordinates: [\r\n        [\r\n          [nw.lng, nw.lat],\r\n          [nw.lng, se.lat],\r\n          [se.lng, se.lat],\r\n          [se.lng, nw.lat],\r\n          [nw.lng, nw.lat],\r\n        ],\r\n      ],\r\n    };\r\n  }\r\n\r\n  /** Calculates the 3D polygon of this Space and returns the vertices of that polygon. */\r\n  vertices3d(): [number, number, number][] {\r\n    const [nw, se] = getBBox(this.zfxy);\r\n    const floor = getFloor(this.zfxy);\r\n    const ceil = getFloor({...this.zfxy, f: this.zfxy.f + 1});\r\n    return [\r\n      [nw.lng, nw.lat, floor],\r\n      [nw.lng, se.lat, floor],\r\n      [se.lng, se.lat, floor],\r\n      [se.lng, nw.lat, floor],\r\n      [nw.lng, nw.lat, ceil],\r\n      [nw.lng, se.lat, ceil],\r\n      [se.lng, se.lat, ceil],\r\n      [se.lng, nw.lat, ceil],\r\n    ];\r\n  }\r\n\r\n  static getSpaceById(id: string, zoom?: number) {\r\n    return new Space(id, zoom);\r\n  }\r\n\r\n  static getSpaceByLocation(loc: LngLatWithAltitude, zoom?: number) {\r\n    return new Space(loc, zoom);\r\n  }\r\n\r\n  static getSpaceByZFXY(zfxyStr: string) {\r\n    return new Space(zfxyStr);\r\n  }\r\n\r\n  /** Calculates the smallest spatial ID to fully contain the polygon. Currently only supports 2D polygons. */\r\n  static boundingSpaceForGeometry(geom: Geometry, minZoom?: number): Space {\r\n    minZoom = minZoom || 25;\r\n    const bbox = turfBBox(geom);\r\n    const largestTile = bboxToTile(bbox, minZoom);\r\n    const [ x, y, z ] = largestTile;\r\n    return new Space({x, y, z, f: 0});\r\n  }\r\n\r\n  /** Calculate an array of spaces that make up the polygon. Currently only supports 2D polygons. */\r\n  static spacesForGeometry(geom: Geometry, zoom: number): Space[] {\r\n    const z = zoom;\r\n\r\n    if (z === 0) {\r\n      // not recommended.\r\n      return [new Space('0/0/0/0')];\r\n    }\r\n\r\n    if (geom.type === 'GeometryCollection') {\r\n      throw new Error('GeometryCollection not supported');\r\n    }\r\n\r\n    // this can be optimized a lot!\r\n    const bbox = turfBBox(geom),\r\n          min = pointToTile(bbox[0], bbox[1], 32),\r\n          max = pointToTile(bbox[2], bbox[3], 32),\r\n          minX = (Math.min(min[0], max[0])) >>> (32 - z),\r\n          minY = (Math.min(min[1], max[1])) >>> (32 - z),\r\n          maxX = (Math.max(max[0], min[0]) >>> (32 - z)) + 1,\r\n          maxY = (Math.max(max[1], min[1]) >>> (32 - z)) + 1,\r\n          spaces: Space[] = [];\r\n\r\n    // scanline polygon fill algorithm\r\n    for (let x = minX; x <= maxX; x++) {\r\n      for (let y = minY; y <= maxY; y++) {\r\n        const space = new Space({x, y, z, f: 0});\r\n        if (turfBooleanIntersects(geom, space.toGeoJSON())) {\r\n          spaces.push(space);\r\n        }\r\n      }\r\n    }\r\n    return spaces;\r\n  }\r\n\r\n  private _regenerateAttributesFromZFXY() {\r\n    this.alt = getFloor(this.zfxy);\r\n    this.center = getCenterLngLatAlt(this.zfxy);\r\n    this.zoom = this.zfxy.z;\r\n    this.id = this.tilehash = generateTilehash(this.zfxy);\r\n    this.zfxyStr = `/${this.zfxy.z}/${this.zfxy.f}/${this.zfxy.x}/${this.zfxy.y}`;\r\n  }\r\n}\r\n","\r\nimport { ZFXYTile, getChildren, getParent, ZFXY_ROOT_TILE } from \"./zfxy\";\r\n\r\n/**\r\n * tilehash  ZFXYTile \r\n * -  '-'  f \r\n * -  1..N  children (1-based)\r\n */\r\nexport function parseZFXYTilehash(th: string): ZFXYTile {\r\n  if (th == null) {\r\n    throw new Error(\"parseZFXYTilehash: tilehash \");\r\n  }\r\n\r\n  let negativeF = false;\r\n  let s = th.trim();\r\n\r\n  // \r\n  if (s.startsWith(\"-\")) {\r\n    negativeF = true;\r\n    s = s.slice(1);\r\n  }\r\n\r\n  // \r\n  if (s.length === 0) {\r\n    throw new Error(\"parseZFXYTilehash: '-' \");\r\n  }\r\n\r\n  // \r\n  let children = getChildren();            // \r\n  let lastChild: ZFXYTile | null = null;\r\n\r\n  for (const ch of s) {\r\n    const idx = Number(ch) - 1;\r\n    if (!Number.isInteger(idx) || idx < 0 || idx >= children.length) {\r\n      throw new Error(`parseZFXYTilehash:  '${ch}' `);\r\n    }\r\n    lastChild = { ...children[idx] };\r\n    children = getChildren(lastChild);\r\n  }\r\n\r\n  if (!lastChild) {\r\n    //  s.length === 0 \r\n    // \r\n    // lastChild = { ...ZFXY_ROOT_TILE };\r\n    throw new Error(\"parseZFXYTilehash: lastChild \");\r\n  }\r\n\r\n  // \r\n  if (negativeF) {\r\n    lastChild.f = -Math.abs(lastChild.f);\r\n  }\r\n\r\n  return lastChild;\r\n}\r\n\r\n/**\r\n * ZFXYTile  tilehash \r\n * -  1..N \r\n * - f  '-' \r\n */\r\nexport function generateTilehash(tile: ZFXYTile): string {\r\n  let { f, x, y, z } = tile;\r\n  const originalF = f;\r\n  let out = \"\";\r\n\r\n  while (z > 0) {\r\n    const thisTile: ZFXYTile = { f: Math.abs(f), x, y, z };\r\n    const parent = getParent(thisTile);\r\n    const childrenOfParent = getChildren(parent);\r\n\r\n    const positionInParent = childrenOfParent.findIndex(\r\n      (child) =>\r\n        child.f === Math.abs(f) &&\r\n        child.x === x &&\r\n        child.y === y &&\r\n        child.z === z\r\n    );\r\n\r\n    if (positionInParent < 0) {\r\n      // \r\n      throw new Error(\"generateTilehash:  children \");\r\n    }\r\n\r\n    out = String(positionInParent + 1) + out;\r\n\r\n    // \r\n    f = parent.f;\r\n    x = parent.x;\r\n    y = parent.y;\r\n    z = parent.z;\r\n  }\r\n\r\n  // \r\n  return (originalF < 0 ? \"-\" : \"\") + out;\r\n}\r\n"],"names":["ZFXY_ROOT_TILE","f","x","y","z","rad2deg","Math","PI","getParent","tile","steps","Error","getChildren","getSurrounding","zfxyWraparound","getLngLat","n","pow","lng","lat","atan","exp","getCenterLngLat","getBBox","getFloor","max","min","feature","geom","properties","options","feat","type","id","bbox","geometry","lineString","coordinates","length","featureCollection","features","fc","isNumber","num","isNaN","Array","isArray","coordEach","geojson","callback","excludeWrapCoord","j","k","l","stopG","coords","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","geomType","featureEach","i","flattenEach","g","featureProperties","featureBBox","featureId","undefined","geomEach","coordinate","result","Infinity","coord","getCoords","getGeom","booleanPointInPolygon","point","polygon","pt","getCoord","polys","inBBox","insidePoly","inRing","ignoreBoundary","inHole","ring","isInside","slice","xi","yi","xj","yj","lineSegment","results","forEach","segments","reduce","previousCoords","currentCoords","coords1","coords2","x1","y1","x2","y2","segment","push","createSegments","lineSegmentFeature","module","t","r","e","a","h","o","s","log","u","sqrt","floor","p","d","this","_maxEntries","_minEntries","ceil","clear","indexOf","children","minX","minY","maxX","maxY","leaf","m","c","height","pop","prototype","all","_all","data","search","toBBox","collides","load","insert","_build","_splitRoot","_insert","remove","splice","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","_chooseSubtree","_split","_adjustParentBBoxes","_chooseSplitAxis","_chooseSplitIndex","v","M","_allDistMargin","sort","_i","coordinates_1","multiLineString","multiPoint","multiPolygon","radiansToLength","radians","units","factor","exports","factors","lengthToRadians","distance","radiansToDegrees","Object","defineProperty","value","earthRadius","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","yards","unitsFactors","areaFactors","acres","hectares","_options","points","map","polygons","lineStrings","geometryCollection","round","precision","multiplier","lengthToDegrees","bearingToAzimuth","bearing","angle","degreesToRadians","convertLength","originalUnit","finalUnit","convertArea","area","startFactor","finalFactor","isObject","input","constructor","validateBBox","validateId","js","helpers","require$$0","propEach","segmentEach","segmentIndex","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","lineEach","coordAll","coordReduce","initialValue","previousValue","featureReduce","currentFeature","findPoint","findSegment","flattenReduce","geomReduce","currentGeometry","lineReduce","currentLine","propReduce","currentProperties","segmentReduce","started","meta_1","default","rbush","require$$1","meta","require$$2","turfBBox","require$$3","geojsonRbush","maxEntries","tree","call","equals","json","geojsonRbushModule","lineIntersect","line1","line2","unique","intersect","intersects","match","key","join","x3","y3","x4","y4","denom","numeA","numeB","uA","uB","polygonToLine","poly","coordsToLine","multiPoly","lines","multiPolygonToLine","booleanDisjoint","feature1","feature2","bool","flatten1","flatten2","geom1","geom2","pair1","pair2","isPointOnLine","lineString1","lineString2","isLineOnLine","isLineInPoly","_a","_b","_c","doLinesIntersect","isPolyInPoly","disjoint","isPointOnLineSegment","lineSegmentStart","lineSegmentEnd","dxc","dyc","dxl","dyl","abs","booleanIntersects","d2r","pointToTile","lon","sin","z2","pointToTileFraction","Space","zoom","zfxy","str","parseInt","parseZFXYString","th","negativeF","trim","startsWith","lastChild","ch","idx","Number","isInteger","parseZFXYTilehash","_regenerateAttributesFromZFXY","alt","calculateZFXY","up","by","move","down","north","south","east","west","newSpace","parent","atZoom","surroundings","filter","zfxyStr","contains","position","toGeoJSON","turfBooleanIntersects","nw","se","vertices3d","getSpaceById","getSpaceByLocation","loc","getSpaceByZFXY","boundingSpaceForGeometry","minZoom","largestTile","bboxCoords","mask","getBboxZoom","bboxToTile","spacesForGeometry","spaces","space","center","tilehash","originalF","out","positionInParent","findIndex","child","String","generateTilehash"],"mappings":"gPAQO,MACMA,EAA2B,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAEzDC,EAAU,IAAMC,KAAKC,YAEXC,EAAUC,EAAgBC,EAAgB,GACxD,MAAMT,EAAEA,EAACC,EAACA,EAACC,EAACA,EAACC,EAACA,GAAMK,EACpB,GAAIC,GAAS,EACX,MAAM,IAAIC,MAAM,gCAElB,GAAID,EAAQN,EACV,MAAM,IAAIO,MAAM,0BAA0BF,MAASC,0EAErD,MAAO,CACLT,EAAGA,GAAKS,EACRR,EAAGA,GAAKQ,EACRP,EAAGA,GAAKO,EACRN,EAAGA,EAAKM,EAEZ,CAEM,SAAUE,EAAYH,EAAiBT,GAC3C,MAAMC,EAACA,EAACC,EAACA,EAACC,EAACA,EAACC,EAACA,GAAKK,EAClB,MAAO,CACL,CAACR,EAAO,EAAJA,EAAWC,EAAO,EAAJA,EAAWC,EAAO,EAAJA,EAAWC,EAAGA,EAAE,GAChD,CAACH,EAAO,EAAJA,EAAWC,EAAO,EAAJA,EAAQ,EAAGC,EAAO,EAAJA,EAAWC,EAAGA,EAAE,GAChD,CAACH,EAAO,EAAJA,EAAWC,EAAO,EAAJA,EAAWC,EAAO,EAAJA,EAAQ,EAAGC,EAAGA,EAAE,GAChD,CAACH,EAAO,EAAJA,EAAWC,EAAO,EAAJA,EAAQ,EAAGC,EAAO,EAAJA,EAAQ,EAAGC,EAAGA,EAAE,GAChD,CAACH,EAAO,EAAJA,EAAQ,EAAGC,EAAO,EAAJA,EAAWC,EAAO,EAAJA,EAAWC,EAAGA,EAAE,GAChD,CAACH,EAAO,EAAJA,EAAQ,EAAGC,EAAO,EAAJA,EAAQ,EAAGC,EAAO,EAAJA,EAAWC,EAAGA,EAAE,GAChD,CAACH,EAAO,EAAJA,EAAQ,EAAGC,EAAO,EAAJA,EAAWC,EAAO,EAAJA,EAAQ,EAAGC,EAAGA,EAAE,GAChD,CAACH,EAAO,EAAJA,EAAQ,EAAGC,EAAO,EAAJA,EAAQ,EAAGC,EAAO,EAAJA,EAAQ,EAAGC,EAAGA,EAAE,GAEpD,CAEM,SAAUS,EAAeJ,EAAiBT,GAC9C,MAAMC,EAACA,EAACC,EAACA,EAACC,EAACA,EAACC,EAACA,GAAKK,EAClB,MAAO,CACLK,EAAe,CAACb,EAAGA,EAAGC,EAAGA,EAAOC,EAAGA,EAAOC,EAAGA,IAC7CU,EAAe,CAACb,EAAGA,EAAGC,EAAGA,EAAI,EAAGC,EAAGA,EAAOC,EAAGA,IAC7CU,EAAe,CAACb,EAAGA,EAAGC,EAAGA,EAAOC,EAAGA,EAAI,EAAGC,EAAGA,IAC7CU,EAAe,CAACb,EAAGA,EAAGC,EAAGA,EAAI,EAAGC,EAAGA,EAAI,EAAGC,EAAGA,IAC7CU,EAAe,CAACb,EAAGA,EAAGC,EAAGA,EAAI,EAAGC,EAAGA,EAAOC,EAAGA,IAC7CU,EAAe,CAACb,EAAGA,EAAGC,EAAGA,EAAOC,EAAGA,EAAI,EAAGC,EAAGA,IAC7CU,EAAe,CAACb,EAAGA,EAAGC,EAAGA,EAAI,EAAGC,EAAGA,EAAI,EAAGC,EAAGA,IAC7CU,EAAe,CAACb,EAAGA,EAAGC,EAAGA,EAAI,EAAGC,EAAGA,EAAI,EAAGC,EAAGA,IAC7CU,EAAe,CAACb,EAAGA,EAAGC,EAAGA,EAAI,EAAGC,EAAGA,EAAI,EAAGC,EAAGA,IAEjD,CAgBM,SAAUW,EAAUN,GACxB,MAAMO,EAAIV,KAAKC,GAAK,EAAID,KAAKC,GAAKE,EAAKN,EAAIG,KAAKW,IAAI,EAAGR,EAAKL,GAC5D,MAAO,CACLc,IAAKT,EAAKP,EAAII,KAAKW,IAAI,EAAGR,EAAKL,GAAK,IAAM,IAC1Ce,IAAKd,EAAUC,KAAKc,KAAK,IAAOd,KAAKe,IAAIL,GAAKV,KAAKe,KAAKL,KAE5D,CAEM,SAAUM,EAAgBb,GAI9B,OAAOM,EAAU,CAACb,EAHC,EAATO,EAAKP,EAAQ,EAGFC,EAFF,EAATM,EAAKN,EAAQ,EAECC,EADdK,EAAKL,EAAI,GAErB,CASM,SAAUmB,EAAQd,GAGtB,MAAO,CAFIM,EAAUN,GACVM,EAAU,IAAIN,EAAMN,EAAGM,EAAKN,EAAI,EAAGD,EAAGO,EAAKP,EAAI,IAE5D,CAGM,SAAUsB,EAASf,GACvB,gBAAOA,EAAKR,EAA8B,GAAGQ,EAAKL,CACpD,CAyCM,SAAUU,EAAeL,GAC7B,MAAML,EAACA,EAACH,EAAEA,EAACC,EAAEA,EAACC,EAAEA,GAAKM,EACrB,MAAO,CACLL,IACAH,EAAGK,KAAKmB,IAAInB,KAAKoB,IAAIzB,EAAI,GAAGG,KAAO,GAAGA,IACtCF,EAAIA,EAAI,EAAKA,EAAI,GAAGE,EAAIF,EAAI,GAAGE,EAC/BD,EAAIA,EAAI,EAAKA,EAAI,GAAGC,EAAID,EAAI,GAAGC,EAEnC,CCtDO,SAASuB,EAAQC,EAAMC,EAAYC,QACtB,IAAZA,IAAsBA,EAAU,CAAA,GACpC,IAAIC,EAAO,CAAEC,KAAM,WASnB,OARmB,IAAfF,EAAQG,IAAYH,EAAQG,MAC5BF,EAAKE,GAAKH,EAAQG,IAElBH,EAAQI,OACRH,EAAKG,KAAOJ,EAAQI,MAExBH,EAAKF,WAAaA,GAAc,CAAA,EAChCE,EAAKI,SAAWP,EACTG,CACX,CA4KO,SAASK,EAAWC,EAAaR,EAAYC,GAEhD,QADgB,IAAZA,IAAsBA,EAAU,CAAA,GAChCO,EAAYC,OAAS,EACrB,MAAM,IAAI3B,MAAM,yDAMpB,OAAOgB,EAJI,CACPK,KAAM,aACNK,YAAaA,GAEIR,EAAYC,EACrC,CAgDO,SAASS,EAAkBC,EAAUV,QACxB,IAAZA,IAAsBA,EAAU,CAAA,GACpC,IAAIW,EAAK,CAAET,KAAM,qBAQjB,OAPIF,EAAQG,KACRQ,EAAGR,GAAKH,EAAQG,IAEhBH,EAAQI,OACRO,EAAGP,KAAOJ,EAAQI,MAEtBO,EAAGD,SAAWA,EACPC,CACX,CAsQO,SAASC,EAASC,GACrB,OAAQC,MAAMD,IAAgB,OAARA,IAAiBE,MAAMC,QAAQH,EACzD,CCpkBA,SAASI,EAAUC,EAASC,EAAUC,GAEpC,GAAgB,OAAZF,EA4BJ,IA3BA,IAAIG,EACFC,EACAC,EACAlB,EACAmB,EACAC,EACAC,EAGAC,EAFAC,EAAa,EACbC,EAAa,EAEb3B,EAAOgB,EAAQhB,KACf4B,EAA+B,sBAAT5B,EACtB6B,EAAqB,YAAT7B,EACZ8B,EAAOF,EAAsBZ,EAAQR,SAASF,OAAS,EAchDyB,EAAe,EAAGA,EAAeD,EAAMC,IAAgB,CAS9DT,GAHAG,KALAD,EAA0BI,EACtBZ,EAAQR,SAASuB,GAAc5B,SAC/B0B,EACAb,EAAQb,SACRa,IAEiC,uBAAjCQ,EAAwBxB,MAGxBwB,EAAwBQ,WAAW1B,OACnC,EAEJ,IAAK,IAAI2B,EAAY,EAAGA,EAAYX,EAAOW,IAAa,CACtD,IAAIC,EAAoB,EACpBC,EAAgB,EAMpB,GAAiB,QALjBhC,EAAWsB,EACPD,EAAwBQ,WAAWC,GACnCT,GAGJ,CACAD,EAASpB,EAASE,YAClB,IAAI+B,EAAWjC,EAASH,KAQxB,OANA0B,EAIM,EAEEU,GACN,KAAK,KACH,MACF,IAAK,QACH,IAOQ,IANNnB,EACEM,EACAI,EACAI,EACAG,EACAC,GAGF,OAAO,EACTR,IACAO,IACA,MACF,IAAK,aACL,IAAK,aACH,IAAKf,EAAI,EAAGA,EAAII,EAAOjB,OAAQa,IAAK,CAClC,IAOQ,IANNF,EACEM,EAAOJ,GACPQ,EACAI,EACAG,EACAC,GAGF,OAAO,EACTR,IACiB,eAAbS,GAA2BF,GACjC,CACiB,eAAbE,GAA2BF,IAC/B,MACF,IAAK,UACL,IAAK,kBACH,IAAKf,EAAI,EAAGA,EAAII,EAAOjB,OAAQa,IAAK,CAClC,IAAKC,EAAI,EAAGA,EAAIG,EAAOJ,GAAGb,OAASoB,EAAYN,IAAK,CAClD,IAOQ,IANNH,EACEM,EAAOJ,GAAGC,GACVO,EACAI,EACAG,EACAC,GAGF,OAAO,EACTR,GACF,CACiB,oBAAbS,GAAgCF,IACnB,YAAbE,GAAwBD,GAC9B,CACiB,YAAbC,GAAwBF,IAC5B,MACF,IAAK,eACH,IAAKf,EAAI,EAAGA,EAAII,EAAOjB,OAAQa,IAAK,CAElC,IADAgB,EAAgB,EACXf,EAAI,EAAGA,EAAIG,EAAOJ,GAAGb,OAAQc,IAAK,CACrC,IAAKC,EAAI,EAAGA,EAAIE,EAAOJ,GAAGC,GAAGd,OAASoB,EAAYL,IAAK,CACrD,IAOQ,IANNJ,EACEM,EAAOJ,GAAGC,GAAGC,GACbM,EACAI,EACAG,EACAC,GAGF,OAAO,EACTR,GACF,CACAQ,GACF,CACAD,GACF,CACA,MACF,IAAK,qBACH,IAAKf,EAAI,EAAGA,EAAIhB,EAAS6B,WAAW1B,OAAQa,IAC1C,IAEE,IADAJ,EAAUZ,EAAS6B,WAAWb,GAAIF,GAGlC,OAAO,EACX,MACF,QACE,MAAM,IAAItC,MAAM,yBAjGG,CAmGzB,CACF,CACF,CA0MA,SAAS0D,EAAYrB,EAASC,GAC5B,GAAqB,YAAjBD,EAAQhB,KACViB,EAASD,EAAS,QACb,GAAqB,sBAAjBA,EAAQhB,KACjB,IAAK,IAAIsC,EAAI,EAAGA,EAAItB,EAAQR,SAASF,SACM,IAArCW,EAASD,EAAQR,SAAS8B,GAAIA,GADSA,KAIjD,CA0UA,SAASC,EAAYvB,EAASC,IA7N9B,SAAkBD,EAASC,GACzB,IAAIqB,EACFnB,EACAqB,EACArC,EACAmB,EACAE,EACAC,EACAgB,EACAC,EACAC,EACAZ,EAAe,EACfH,EAAuC,sBAAjBZ,EAAQhB,KAC9B6B,EAA6B,YAAjBb,EAAQhB,KACpB8B,EAAOF,EAAsBZ,EAAQR,SAASF,OAAS,EAczD,IAAKgC,EAAI,EAAGA,EAAIR,EAAMQ,IAAK,CA4BzB,IA3BAd,EAA0BI,EACtBZ,EAAQR,SAAS8B,GAAGnC,SACpB0B,EACAb,EAAQb,SACRa,EACJyB,EAAoBb,EAChBZ,EAAQR,SAAS8B,GAAGzC,WACpBgC,EACAb,EAAQnB,WACR,CAAA,EACJ6C,EAAcd,EACVZ,EAAQR,SAAS8B,GAAGpC,KACpB2B,EACAb,EAAQd,UACR0C,EACJD,EAAYf,EACRZ,EAAQR,SAAS8B,GAAGrC,GACpB4B,EACAb,EAAQf,QACR2C,EAIJtB,GAHAG,IAAuBD,GACc,uBAAjCA,EAAwBxB,MAGxBwB,EAAwBQ,WAAW1B,OACnC,EAECkC,EAAI,EAAGA,EAAIlB,EAAOkB,IAMrB,GAAiB,QALjBrC,EAAWsB,EACPD,EAAwBQ,WAAWQ,GACnChB,GAgBJ,OAAQrB,EAASH,MACf,IAAK,QACL,IAAK,aACL,IAAK,aACL,IAAK,UACL,IAAK,kBACL,IAAK,eACH,IAOQ,IANNiB,EACEd,EACA4B,EACAU,EACAC,EACAC,GAGF,OAAO,EACT,MAEF,IAAK,qBACH,IAAKxB,EAAI,EAAGA,EAAIhB,EAAS6B,WAAW1B,OAAQa,IAC1C,IAOQ,IANNF,EACEd,EAAS6B,WAAWb,GACpBY,EACAU,EACAC,EACAC,GAGF,OAAO,EAEX,MAEF,QACE,MAAM,IAAIhE,MAAM,8BA/ClB,IAOQ,IANNsC,EACE,KACAc,EACAU,EACAC,EACAC,GAGF,OAAO,EA0CbZ,GACF,CACF,CA0GEc,CAAS7B,EAAS,SAAUb,EAAU4B,EAAclC,EAAYK,EAAMD,GAEpE,IAiBImC,EAjBApC,EAAoB,OAAbG,EAAoB,KAAOA,EAASH,KAC/C,OAAQA,GACN,KAAK,KACL,IAAK,QACL,IAAK,aACL,IAAK,UACH,OAKQ,IAJNiB,EACEtB,EAAQQ,EAAUN,EAAY,CAAEK,KAAMA,EAAMD,GAAIA,IAChD8B,EACA,SAIJ,EAMJ,OAAQ/B,GACN,IAAK,aACHoC,EAAW,QACX,MACF,IAAK,kBACHA,EAAW,aACX,MACF,IAAK,eACHA,EAAW,UAIf,IACE,IAAIF,EAAoB,EACxBA,EAAoB/B,EAASE,YAAYC,OACzC4B,IACA,CACA,IAAIY,EAAa3C,EAASE,YAAY6B,GAKtC,IAEE,IADAjB,EAAStB,EALA,CACTK,KAAMoC,EACN/B,YAAayC,GAGUjD,GAAakC,EAAcG,GAGlD,OAAO,CACX,CACF,EACF,CC5vBA,SAAShC,EAAKc,GACV,IAAI+B,EAAS,CAACC,IAAUA,KAAWA,KAAWA,KAe9C,OAdAjC,EAAUC,EAAS,SAAUiC,GACrBF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,IAElBF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,IAElBF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,IAElBF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,GAE1B,GACOF,CACX,CCeO,SAASG,EAAU3B,GACtB,GAAIV,MAAMC,QAAQS,GACd,OAAOA,EAGX,GAAoB,YAAhBA,EAAOvB,MACP,GAAwB,OAApBuB,EAAOpB,SACP,OAAOoB,EAAOpB,SAASE,iBAK3B,GAAIkB,EAAOlB,YACP,OAAOkB,EAAOlB,YAGtB,MAAM,IAAI1B,MAAM,8DACpB,CA2HO,SAASwE,EAAQnC,GACpB,MAAqB,YAAjBA,EAAQhB,KACDgB,EAAQb,SAEZa,CACX,CCpKe,SAASoC,EAAsBC,EAAOC,EAASxD,GAG1D,QAFgB,IAAZA,IAAsBA,EAAU,CAAA,IAE/BuD,EACD,MAAM,IAAI1E,MAAM,qBAEpB,IAAK2E,EACD,MAAM,IAAI3E,MAAM,uBAEpB,IAAI4E,EDxBD,SAAkBN,GACrB,IAAKA,EACD,MAAM,IAAItE,MAAM,qBAEpB,IAAKkC,MAAMC,QAAQmC,GAAQ,CACvB,GAAmB,YAAfA,EAAMjD,MACa,OAAnBiD,EAAM9C,UACkB,UAAxB8C,EAAM9C,SAASH,KACf,OAAOiD,EAAM9C,SAASE,YAE1B,GAAmB,UAAf4C,EAAMjD,KACN,OAAOiD,EAAM5C,WAErB,CACA,GAAIQ,MAAMC,QAAQmC,IACdA,EAAM3C,QAAU,IACfO,MAAMC,QAAQmC,EAAM,MACpBpC,MAAMC,QAAQmC,EAAM,IACrB,OAAOA,EAEX,MAAM,IAAItE,MAAM,qDACpB,CCGa6E,CAASH,GACdzD,EAAOuD,EAAQG,GACftD,EAAOJ,EAAKI,KACZE,EAAOoD,EAAQpD,KACfuD,EAAQ7D,EAAKS,YAEjB,GAAIH,IAA6B,IAqErC,SAAgBqD,EAAIrD,GAChB,OAAQA,EAAK,IAAMqD,EAAG,IAAMrD,EAAK,IAAMqD,EAAG,IAAMrD,EAAK,IAAMqD,EAAG,IAAMrD,EAAK,IAAMqD,EAAG,EACtF,CAvEgBG,CAAOH,EAAIrD,GACnB,OAAO,EAGE,YAATF,IACAyD,EAAQ,CAACA,IAGb,IADA,IAAIE,GAAa,EACRrB,EAAI,EAAGA,EAAImB,EAAMnD,SAAWqD,EAAYrB,IAE7C,GAAIsB,EAAOL,EAAIE,EAAMnB,GAAG,GAAIxC,EAAQ+D,gBAAiB,CAIjD,IAHA,IAAIC,GAAS,EACT1C,EAAI,EAEDA,EAAIqC,EAAMnB,GAAGhC,SAAWwD,GACvBF,EAAOL,EAAIE,EAAMnB,GAAGlB,IAAKtB,EAAQ+D,kBACjCC,GAAS,GAEb1C,IAEC0C,IACDH,GAAa,EAErB,CAEJ,OAAOA,CACX,CAUA,SAASC,EAAOL,EAAIQ,EAAMF,GACtB,IAAIG,GAAW,EACXD,EAAK,GAAG,KAAOA,EAAKA,EAAKzD,OAAS,GAAG,IACrCyD,EAAK,GAAG,KAAOA,EAAKA,EAAKzD,OAAS,GAAG,KACrCyD,EAAOA,EAAKE,MAAM,EAAGF,EAAKzD,OAAS,IAEvC,IAAK,IAAIgC,EAAI,EAAGnB,EAAI4C,EAAKzD,OAAS,EAAGgC,EAAIyB,EAAKzD,OAAQa,EAAImB,IAAK,CAC3D,IAAI4B,EAAKH,EAAKzB,GAAG,GACb6B,EAAKJ,EAAKzB,GAAG,GACb8B,EAAKL,EAAK5C,GAAG,GACbkD,EAAKN,EAAK5C,GAAG,GAIjB,GAHiBoC,EAAG,IAAMW,EAAKE,GAAMD,GAAMC,EAAKb,EAAG,IAAMc,GAAMd,EAAG,GAAKW,KAAQ,IAC1EA,EAAKX,EAAG,KAAOa,EAAKb,EAAG,KAAO,IAC9BY,EAAKZ,EAAG,KAAOc,EAAKd,EAAG,KAAO,EAE/B,OAAQM,EAEIM,EAAKZ,EAAG,IAAOc,EAAKd,EAAG,IACnCA,EAAG,IAAOa,EAAKF,IAAOX,EAAG,GAAKY,IAAQE,EAAKF,GAAMD,IAEjDF,GAAYA,EAEpB,CACA,OAAOA,CACX,CCtFA,SAASM,EAAYtD,GACjB,IAAKA,EACD,MAAM,IAAIrC,MAAM,uBAEpB,IAAI4F,EAAU,GAId,OAHAhC,EAAYvB,EAAS,SAAUrB,IAanC,SAA4BqB,EAASuD,GACjC,IAAIhD,EAAS,GACTpB,EAAWa,EAAQb,SACvB,GAAiB,OAAbA,EAAmB,CACnB,OAAQA,EAASH,MACb,IAAK,UACDuB,EAAS2B,EAAU/C,GACnB,MACJ,IAAK,aACDoB,EAAS,CAAC2B,EAAU/C,IAE5BoB,EAAOiD,QAAQ,SAAUvB,GACrB,IAAIwB,EAgBhB,SAAwBlD,EAAQ1B,GAC5B,IAAI4E,EAAW,GAOf,OANAlD,EAAOmD,OAAO,SAAUC,EAAgBC,GACpC,IAeMC,EAASC,EACfC,EACAC,EACAC,EACAC,EAnBIC,EAAU/E,EAAW,CAACuE,EAAgBC,GAAgB/E,GAG1D,OAFAsF,EAAQjF,MAcO4E,EAdqBF,EAepCG,GADMF,EAdcF,GAeP,GACbK,EAAKH,EAAQ,GACbI,EAAKH,EAAQ,GACbI,EAAKJ,EAAQ,GAKV,CAJIC,EAAKE,EAAKF,EAAKE,EACdD,EAAKE,EAAKF,EAAKE,EAChBH,EAAKE,EAAKF,EAAKE,EACdD,EAAKE,EAAKF,EAAKE,IArBvBT,EAASW,KAAKD,GACPP,CACX,GACOH,CACX,CAzB2BY,CAAepC,EAAOjC,EAAQnB,YAC7C4E,EAASD,QAAQ,SAAUW,GACvBA,EAAQlF,GAAKsE,EAAQjE,OACrBiE,EAAQa,KAAKD,EACjB,EACJ,EACJ,CACJ,CA/BQG,CAAmB3F,EAAS4E,EAChC,GACOhE,EAAkBgE,EAC7B,qGHOArE,EAAc,QAAIA,8EIjCkDqF,UAA+F,WAAwB,SAASC,EAAEA,EAAEC,EAAEC,EAAEC,EAAEC,IAAI,SAASJ,EAAExG,EAAEyG,EAAEC,EAAEC,EAAEC,GAAG,KAAKD,EAAED,GAAG,CAAC,GAAGC,EAAED,EAAE,IAAI,CAAC,IAAIG,EAAEF,EAAED,EAAE,EAAEI,EAAEL,EAAEC,EAAE,EAAErE,EAAE/C,KAAKyH,IAAIF,GAAG5H,EAAE,GAAGK,KAAKe,IAAI,EAAEgC,EAAE,GAAG2E,EAAE,GAAG1H,KAAK2H,KAAK5E,EAAEpD,GAAG4H,EAAE5H,GAAG4H,IAAIC,EAAED,EAAE,EAAE,GAAE,EAAG,GAA+EL,EAAExG,EAAEyG,EAA9EnH,KAAKmB,IAAIiG,EAAEpH,KAAK4H,MAAMT,EAAEK,EAAE7H,EAAE4H,EAAEG,IAAM1H,KAAKoB,IAAIiG,EAAErH,KAAK4H,MAAMT,GAAGI,EAAEC,GAAG7H,EAAE4H,EAAEG,IAAcJ,EAAE,CAAC,IAAIO,EAAEnH,EAAEyG,GAAGW,EAAEV,EAAExH,EAAEyH,EAAE,IAAIrD,EAAEtD,EAAE0G,EAAED,GAAGG,EAAE5G,EAAE2G,GAAGQ,GAAG,GAAG7D,EAAEtD,EAAE0G,EAAEC,GAAGS,EAAElI,GAAG,CAAC,IAAIoE,EAAEtD,EAAEoH,EAAElI,GAAGkI,IAAIlI,IAAI0H,EAAE5G,EAAEoH,GAAGD,GAAG,GAAGC,IAAI,KAAKR,EAAE5G,EAAEd,GAAGiI,GAAG,GAAGjI,GAAG,CAAC,IAAI0H,EAAE5G,EAAE0G,GAAGS,GAAG7D,EAAEtD,EAAE0G,EAAExH,GAAGoE,EAAEtD,IAAId,EAAEyH,GAAGzH,GAAGuH,IAAIC,EAAExH,EAAE,GAAGuH,GAAGvH,IAAIyH,EAAEzH,EAAE,EAAE,CAAC,CAA9Z,CAAgasH,EAAEC,EAAEC,GAAG,EAAEC,GAAGH,EAAElF,OAAO,EAAEsF,GAAG5G,EAAE,CAAC,SAASsD,EAAEkD,EAAElD,EAAEtD,GAAG,IAAIyG,EAAED,EAAElD,GAAGkD,EAAElD,GAAGkD,EAAExG,GAAGwG,EAAExG,GAAGyG,CAAC,CAAC,SAASzG,EAAEwG,EAAElD,GAAG,OAAOkD,EAAElD,KAAKkD,EAAElD,EAAE,EAAE,CAAC,CAAC,IAAImD,EAAE,SAASD,QAAG,IAASA,IAAIA,EAAE,GAAGa,KAAKC,YAAYhI,KAAKmB,IAAI,EAAE+F,GAAGa,KAAKE,YAAYjI,KAAKmB,IAAI,EAAEnB,KAAKkI,KAAK,GAAGH,KAAKC,cAAcD,KAAKI,OAAO,EAAE,SAASf,EAAEF,EAAElD,EAAEtD,GAAG,IAAIA,EAAE,OAAOsD,EAAEoE,QAAQlB,GAAG,IAAI,IAAIC,EAAE,EAAEA,EAAEnD,EAAEhC,OAAOmF,IAAI,GAAGzG,EAAEwG,EAAElD,EAAEmD,IAAI,OAAOA,EAAE,OAAM,CAAE,CAAC,SAASE,EAAEH,EAAElD,GAAGsD,EAAEJ,EAAE,EAAEA,EAAEmB,SAASrG,OAAOgC,EAAEkD,EAAE,CAAC,SAASI,EAAEJ,EAAElD,EAAEtD,EAAEyG,EAAEC,GAAGA,IAAIA,EAAES,EAAE,OAAOT,EAAEkB,KAAK,IAAIlB,EAAEmB,KAAK,IAAInB,EAAEoB,MAAK,IAAKpB,EAAEqB,MAAK,IAAK,IAAI,IAAIpB,EAAErD,EAAEqD,EAAE3G,EAAE2G,IAAI,CAAC,IAAIC,EAAEJ,EAAEmB,SAAShB,GAAGE,EAAEH,EAAEF,EAAEwB,KAAKvB,EAAEG,GAAGA,EAAE,CAAC,OAAOF,CAAC,CAAC,SAASG,EAAEL,EAAElD,GAAG,OAAOkD,EAAEoB,KAAKtI,KAAKoB,IAAI8F,EAAEoB,KAAKtE,EAAEsE,MAAMpB,EAAEqB,KAAKvI,KAAKoB,IAAI8F,EAAEqB,KAAKvE,EAAEuE,MAAMrB,EAAEsB,KAAKxI,KAAKmB,IAAI+F,EAAEsB,KAAKxE,EAAEwE,MAAMtB,EAAEuB,KAAKzI,KAAKmB,IAAI+F,EAAEuB,KAAKzE,EAAEyE,MAAMvB,CAAC,CAAC,SAASM,EAAEN,EAAElD,GAAG,OAAOkD,EAAEoB,KAAKtE,EAAEsE,IAAI,CAAC,SAASvF,EAAEmE,EAAElD,GAAG,OAAOkD,EAAEqB,KAAKvE,EAAEuE,IAAI,CAAC,SAAS5I,EAAEuH,GAAG,OAAOA,EAAEsB,KAAKtB,EAAEoB,OAAOpB,EAAEuB,KAAKvB,EAAEqB,KAAK,CAAC,SAASb,EAAER,GAAG,OAAOA,EAAEsB,KAAKtB,EAAEoB,MAAMpB,EAAEuB,KAAKvB,EAAEqB,KAAK,CAAC,SAASI,EAAEzB,EAAElD,GAAG,OAAOkD,EAAEoB,MAAMtE,EAAEsE,MAAMpB,EAAEqB,MAAMvE,EAAEuE,MAAMvE,EAAEwE,MAAMtB,EAAEsB,MAAMxE,EAAEyE,MAAMvB,EAAEuB,IAAI,CAAC,SAASG,EAAE1B,EAAElD,GAAG,OAAOA,EAAEsE,MAAMpB,EAAEsB,MAAMxE,EAAEuE,MAAMrB,EAAEuB,MAAMzE,EAAEwE,MAAMtB,EAAEoB,MAAMtE,EAAEyE,MAAMvB,EAAEqB,IAAI,CAAC,SAASV,EAAEX,GAAG,MAAM,CAACmB,SAASnB,EAAE2B,OAAO,EAAEH,MAAK,EAAGJ,KAAK,IAAIC,KAAK,IAAIC,MAAK,IAAKC,MAAK,IAAK,CAAC,SAASX,EAAE9D,EAAEtD,EAAEyG,EAAEC,EAAEC,GAAG,IAAI,IAAIC,EAAE,CAAC5G,EAAEyG,GAAGG,EAAEtF,QAAQ,MAAMmF,EAAEG,EAAEwB,QAAQpI,EAAE4G,EAAEwB,QAAQ1B,GAAG,CAAC,IAAIG,EAAE7G,EAAEV,KAAKkI,MAAMf,EAAEzG,GAAG0G,EAAE,GAAGA,EAAEF,EAAElD,EAAEuD,EAAE7G,EAAEyG,EAAEE,GAAGC,EAAER,KAAKpG,EAAE6G,EAAEA,EAAEJ,EAAE,CAAC,CAAC,OAAOA,EAAE4B,UAAUC,IAAI,WAAW,OAAOjB,KAAKkB,KAAKlB,KAAKmB,KAAK,GAAG,EAAE/B,EAAE4B,UAAUI,OAAO,SAASjC,GAAG,IAAIlD,EAAE+D,KAAKmB,KAAKxI,EAAE,GAAG,IAAIkI,EAAE1B,EAAElD,GAAG,OAAOtD,EAAE,IAAI,IAAIyG,EAAEY,KAAKqB,OAAOhC,EAAE,GAAGpD,GAAG,CAAC,IAAI,IAAIqD,EAAE,EAAEA,EAAErD,EAAEqE,SAASrG,OAAOqF,IAAI,CAAC,IAAIC,EAAEtD,EAAEqE,SAAShB,GAAGE,EAAEvD,EAAE0E,KAAKvB,EAAEG,GAAGA,EAAEsB,EAAE1B,EAAEK,KAAKvD,EAAE0E,KAAKhI,EAAEoG,KAAKQ,GAAGqB,EAAEzB,EAAEK,GAAGQ,KAAKkB,KAAK3B,EAAE5G,GAAG0G,EAAEN,KAAKQ,GAAG,CAACtD,EAAEoD,EAAE0B,KAAK,CAAC,OAAOpI,CAAC,EAAEyG,EAAE4B,UAAUM,SAAS,SAASnC,GAAG,IAAIlD,EAAE+D,KAAKmB,KAAK,IAAIN,EAAE1B,EAAElD,GAAG,OAAM,EAAG,IAAI,IAAItD,EAAE,GAAGsD,GAAG,CAAC,IAAI,IAAImD,EAAE,EAAEA,EAAEnD,EAAEqE,SAASrG,OAAOmF,IAAI,CAAC,IAAIC,EAAEpD,EAAEqE,SAASlB,GAAGE,EAAErD,EAAE0E,KAAKX,KAAKqB,OAAOhC,GAAGA,EAAE,GAAGwB,EAAE1B,EAAEG,GAAG,CAAC,GAAGrD,EAAE0E,MAAMC,EAAEzB,EAAEG,GAAG,OAAM,EAAG3G,EAAEoG,KAAKM,EAAE,CAAC,CAACpD,EAAEtD,EAAEoI,KAAK,CAAC,OAAM,CAAE,EAAE3B,EAAE4B,UAAUO,KAAK,SAASpC,GAAG,IAAIA,IAAIA,EAAElF,OAAO,OAAO+F,KAAK,GAAGb,EAAElF,OAAO+F,KAAKE,YAAY,CAAC,IAAI,IAAIjE,EAAE,EAAEA,EAAEkD,EAAElF,OAAOgC,IAAI+D,KAAKwB,OAAOrC,EAAElD,IAAI,OAAO+D,IAAI,CAAC,IAAIrH,EAAEqH,KAAKyB,OAAOtC,EAAEvB,QAAQ,EAAEuB,EAAElF,OAAO,EAAE,GAAG,GAAG+F,KAAKmB,KAAKb,SAASrG,OAAO,GAAG+F,KAAKmB,KAAKL,SAASnI,EAAEmI,OAAOd,KAAK0B,WAAW1B,KAAKmB,KAAKxI,OAAO,CAAC,GAAGqH,KAAKmB,KAAKL,OAAOnI,EAAEmI,OAAO,CAAC,IAAI1B,EAAEY,KAAKmB,KAAKnB,KAAKmB,KAAKxI,EAAEA,EAAEyG,CAAC,CAACY,KAAK2B,QAAQhJ,EAAEqH,KAAKmB,KAAKL,OAAOnI,EAAEmI,OAAO,GAAE,EAAG,MAAMd,KAAKmB,KAAKxI,EAAE,OAAOqH,IAAI,EAAEZ,EAAE4B,UAAUQ,OAAO,SAASrC,GAAG,OAAOA,GAAGa,KAAK2B,QAAQxC,EAAEa,KAAKmB,KAAKL,OAAO,GAAGd,IAAI,EAAEZ,EAAE4B,UAAUZ,MAAM,WAAW,OAAOJ,KAAKmB,KAAKrB,EAAE,IAAIE,IAAI,EAAEZ,EAAE4B,UAAUY,OAAO,SAASzC,EAAElD,GAAG,IAAIkD,EAAE,OAAOa,KAAK,IAAI,IAAIrH,EAAEyG,EAAEE,EAAEC,EAAES,KAAKmB,KAAK3B,EAAEQ,KAAKqB,OAAOlC,GAAGM,EAAE,GAAGzE,EAAE,GAAGuE,GAAGE,EAAExF,QAAQ,CAAC,GAAGsF,IAAIA,EAAEE,EAAEsB,MAAM3B,EAAEK,EAAEA,EAAExF,OAAO,GAAGtB,EAAEqC,EAAE+F,MAAMzB,GAAE,GAAIC,EAAEoB,KAAK,CAAC,IAAI/I,EAAEyH,EAAEF,EAAEI,EAAEe,SAASrE,GAAG,QAAQrE,EAAE,OAAO2H,EAAEe,SAASuB,OAAOjK,EAAE,GAAG6H,EAAEV,KAAKQ,GAAGS,KAAK8B,UAAUrC,GAAGO,IAAI,CAACV,GAAGC,EAAEoB,OAAOC,EAAErB,EAAEC,GAAGJ,GAAGzG,IAAI4G,EAAEH,EAAEkB,SAAS3H,GAAG2G,GAAE,GAAIC,EAAE,MAAME,EAAEV,KAAKQ,GAAGvE,EAAE+D,KAAKpG,GAAGA,EAAE,EAAEyG,EAAEG,EAAEA,EAAEA,EAAEe,SAAS,GAAG,CAAC,OAAON,IAAI,EAAEZ,EAAE4B,UAAUK,OAAO,SAASlC,GAAG,OAAOA,CAAC,EAAEC,EAAE4B,UAAUe,YAAY,SAAS5C,EAAElD,GAAG,OAAOkD,EAAEoB,KAAKtE,EAAEsE,IAAI,EAAEnB,EAAE4B,UAAUgB,YAAY,SAAS7C,EAAElD,GAAG,OAAOkD,EAAEqB,KAAKvE,EAAEuE,IAAI,EAAEpB,EAAE4B,UAAUiB,OAAO,WAAW,OAAOjC,KAAKmB,IAAI,EAAE/B,EAAE4B,UAAUkB,SAAS,SAAS/C,GAAG,OAAOa,KAAKmB,KAAKhC,EAAEa,IAAI,EAAEZ,EAAE4B,UAAUE,KAAK,SAAS/B,EAAElD,GAAG,IAAI,IAAItD,EAAE,GAAGwG,GAAGA,EAAEwB,KAAK1E,EAAE8C,KAAKoD,MAAMlG,EAAEkD,EAAEmB,UAAU3H,EAAEoG,KAAKoD,MAAMxJ,EAAEwG,EAAEmB,UAAUnB,EAAExG,EAAEoI,MAAM,OAAO9E,CAAC,EAAEmD,EAAE4B,UAAUS,OAAO,SAAStC,EAAElD,EAAEtD,EAAEyG,GAAG,IAAIC,EAAEE,EAAE5G,EAAEsD,EAAE,EAAEuD,EAAEQ,KAAKC,YAAY,GAAGV,GAAGC,EAAE,OAAOF,EAAED,EAAES,EAAEX,EAAEvB,MAAM3B,EAAEtD,EAAE,IAAIqH,KAAKqB,QAAQhC,EAAED,IAAIA,EAAEnH,KAAKkI,KAAKlI,KAAKyH,IAAIH,GAAGtH,KAAKyH,IAAIF,IAAIA,EAAEvH,KAAKkI,KAAKZ,EAAEtH,KAAKW,IAAI4G,EAAEJ,EAAE,MAAMC,EAAES,EAAE,KAAKa,MAAK,EAAGtB,EAAEyB,OAAO1B,EAAE,IAAIK,EAAExH,KAAKkI,KAAKZ,EAAEC,GAAGxE,EAAEyE,EAAExH,KAAKkI,KAAKlI,KAAK2H,KAAKJ,IAAIO,EAAEZ,EAAElD,EAAEtD,EAAEqC,EAAEgF,KAAK+B,aAAa,IAAI,IAAInK,EAAEqE,EAAErE,GAAGe,EAAEf,GAAGoD,EAAE,CAAC,IAAI2E,EAAE1H,KAAKoB,IAAIzB,EAAEoD,EAAE,EAAErC,GAAGoH,EAAEZ,EAAEvH,EAAE+H,EAAEF,EAAEO,KAAKgC,aAAa,IAAI,IAAIpB,EAAEhJ,EAAEgJ,GAAGjB,EAAEiB,GAAGnB,EAAE,CAAC,IAAIoB,EAAE5I,KAAKoB,IAAIuH,EAAEnB,EAAE,EAAEE,GAAGN,EAAEiB,SAASvB,KAAKiB,KAAKyB,OAAOtC,EAAEyB,EAAEC,EAAEzB,EAAE,GAAG,CAAC,CAAC,OAAOE,EAAED,EAAEW,KAAKqB,QAAQhC,CAAC,EAAED,EAAE4B,UAAUoB,eAAe,SAASjD,EAAElD,EAAEtD,EAAEyG,GAAG,KAAKA,EAAEL,KAAK9C,IAAIA,EAAE0E,MAAMvB,EAAEnF,OAAO,IAAItB,GAAG,CAAC,IAAI,IAAI0G,EAAE,IAAIC,EAAE,IAAIC,OAAE,EAAOC,EAAE,EAAEA,EAAEvD,EAAEqE,SAASrG,OAAOuF,IAAI,CAAC,IAAIC,EAAExD,EAAEqE,SAASd,GAAGxE,EAAEpD,EAAE6H,GAAGE,GAAGiB,EAAEzB,EAAE0B,EAAEpB,GAAGxH,KAAKmB,IAAIyH,EAAEJ,KAAKG,EAAEH,MAAMxI,KAAKoB,IAAIwH,EAAEN,KAAKK,EAAEL,QAAQtI,KAAKmB,IAAIyH,EAAEH,KAAKE,EAAEF,MAAMzI,KAAKoB,IAAIwH,EAAEL,KAAKI,EAAEJ,OAAOxF,GAAG2E,EAAEL,GAAGA,EAAEK,EAAEN,EAAErE,EAAEqE,EAAErE,EAAEqE,EAAEE,EAAEE,GAAGE,IAAIL,GAAGtE,EAAEqE,IAAIA,EAAErE,EAAEuE,EAAEE,EAAE,CAACxD,EAAEsD,GAAGtD,EAAEqE,SAAS,EAAE,CAAC,IAAIM,EAAEC,EAAE,OAAO5E,CAAC,EAAEmD,EAAE4B,UAAUW,QAAQ,SAASxC,EAAElD,EAAEtD,GAAG,IAAIyG,EAAEzG,EAAEwG,EAAEa,KAAKqB,OAAOlC,GAAGE,EAAE,GAAGC,EAAEU,KAAKoC,eAAehD,EAAEY,KAAKmB,KAAKlF,EAAEoD,GAAG,IAAIC,EAAEgB,SAASvB,KAAKI,GAAGK,EAAEF,EAAEF,GAAGnD,GAAG,GAAGoD,EAAEpD,GAAGqE,SAASrG,OAAO+F,KAAKC,aAAaD,KAAKqC,OAAOhD,EAAEpD,GAAGA,IAAI+D,KAAKsC,oBAAoBlD,EAAEC,EAAEpD,EAAE,EAAEmD,EAAE4B,UAAUqB,OAAO,SAASlD,EAAElD,GAAG,IAAItD,EAAEwG,EAAElD,GAAGmD,EAAEzG,EAAE2H,SAASrG,OAAOoF,EAAEW,KAAKE,YAAYF,KAAKuC,iBAAiB5J,EAAE0G,EAAED,GAAG,IAAIG,EAAES,KAAKwC,kBAAkB7J,EAAE0G,EAAED,GAAGI,EAAEM,EAAEnH,EAAE2H,SAASuB,OAAOtC,EAAE5G,EAAE2H,SAASrG,OAAOsF,IAAIC,EAAEsB,OAAOnI,EAAEmI,OAAOtB,EAAEmB,KAAKhI,EAAEgI,KAAKrB,EAAE3G,EAAEqH,KAAKqB,QAAQ/B,EAAEE,EAAEQ,KAAKqB,QAAQpF,EAAEkD,EAAElD,EAAE,GAAGqE,SAASvB,KAAKS,GAAGQ,KAAK0B,WAAW/I,EAAE6G,EAAE,EAAEJ,EAAE4B,UAAUU,WAAW,SAASvC,EAAElD,GAAG+D,KAAKmB,KAAKrB,EAAE,CAACX,EAAElD,IAAI+D,KAAKmB,KAAKL,OAAO3B,EAAE2B,OAAO,EAAEd,KAAKmB,KAAKR,MAAK,EAAGrB,EAAEU,KAAKmB,KAAKnB,KAAKqB,OAAO,EAAEjC,EAAE4B,UAAUwB,kBAAkB,SAASrD,EAAElD,EAAEtD,GAAG,IAAI,IAAIyG,EAAEC,EAAEC,EAAEE,EAAEC,EAAEzE,EAAE2E,EAAEiB,EAAE,IAAIC,EAAE,IAAIf,EAAE7D,EAAE6D,GAAGnH,EAAEsD,EAAE6D,IAAI,CAAC,IAAIC,EAAER,EAAEJ,EAAE,EAAEW,EAAEE,KAAKqB,QAAQxJ,EAAE0H,EAAEJ,EAAEW,EAAEnH,EAAEqH,KAAKqB,QAAQoB,GAAGpD,EAAEU,EAAET,EAAEzH,EAAE2H,OAAE,EAAOC,OAAE,EAAOzE,OAAE,EAAO2E,OAAE,EAAOH,EAAEvH,KAAKmB,IAAIiG,EAAEkB,KAAKjB,EAAEiB,MAAMd,EAAExH,KAAKmB,IAAIiG,EAAEmB,KAAKlB,EAAEkB,MAAMxF,EAAE/C,KAAKoB,IAAIgG,EAAEoB,KAAKnB,EAAEmB,MAAMd,EAAE1H,KAAKoB,IAAIgG,EAAEqB,KAAKpB,EAAEoB,MAAMzI,KAAKmB,IAAI,EAAE4B,EAAEwE,GAAGvH,KAAKmB,IAAI,EAAEuG,EAAEF,IAAIiD,EAAE9K,EAAEmI,GAAGnI,EAAEC,GAAG4K,EAAE7B,GAAGA,EAAE6B,EAAErD,EAAEU,EAAEe,EAAE6B,EAAE7B,EAAE6B,EAAE7B,GAAG4B,IAAI7B,GAAG8B,EAAE7B,IAAIA,EAAE6B,EAAEtD,EAAEU,EAAE,CAAC,OAAOV,GAAGzG,EAAEsD,CAAC,EAAEmD,EAAE4B,UAAUuB,iBAAiB,SAASpD,EAAElD,EAAEtD,GAAG,IAAIyG,EAAED,EAAEwB,KAAKX,KAAK+B,YAAYtC,EAAEJ,EAAEF,EAAEwB,KAAKX,KAAKgC,YAAYhH,EAAEgF,KAAK2C,eAAexD,EAAElD,EAAEtD,EAAEyG,GAAGY,KAAK2C,eAAexD,EAAElD,EAAEtD,EAAE0G,IAAIF,EAAEmB,SAASsC,KAAKxD,EAAE,EAAEA,EAAE4B,UAAU2B,eAAe,SAASxD,EAAElD,EAAEtD,EAAEyG,GAAGD,EAAEmB,SAASsC,KAAKxD,GAAG,IAAI,IAAIC,EAAEW,KAAKqB,OAAO/B,EAAEC,EAAEJ,EAAE,EAAElD,EAAEoD,GAAGI,EAAEF,EAAEJ,EAAExG,EAAEsD,EAAEtD,EAAE0G,GAAGrE,EAAE2E,EAAEL,GAAGK,EAAEF,GAAG7H,EAAEqE,EAAErE,EAAEe,EAAEsD,EAAErE,IAAI,CAAC,IAAIgJ,EAAEzB,EAAEmB,SAAS1I,GAAG4H,EAAEF,EAAEH,EAAEwB,KAAKtB,EAAEuB,GAAGA,GAAG5F,GAAG2E,EAAEL,EAAE,CAAC,IAAI,IAAIuB,EAAElI,EAAEsD,EAAE,EAAE4E,GAAG5E,EAAE4E,IAAI,CAAC,IAAIf,EAAEX,EAAEmB,SAASO,GAAGrB,EAAEC,EAAEN,EAAEwB,KAAKtB,EAAES,GAAGA,GAAG9E,GAAG2E,EAAEF,EAAE,CAAC,OAAOzE,CAAC,EAAEoE,EAAE4B,UAAUsB,oBAAoB,SAASnD,EAAElD,EAAEtD,GAAG,IAAI,IAAIyG,EAAEzG,EAAEyG,GAAG,EAAEA,IAAII,EAAEvD,EAAEmD,GAAGD,EAAE,EAAEC,EAAE4B,UAAUc,UAAU,SAAS3C,GAAG,IAAI,IAAIlD,EAAEkD,EAAElF,OAAO,EAAEtB,OAAE,EAAOsD,GAAG,EAAEA,IAAI,IAAIkD,EAAElD,GAAGqE,SAASrG,OAAOgC,EAAE,GAAGtD,EAAEwG,EAAElD,EAAE,GAAGqE,UAAUuB,OAAOlJ,EAAE0H,QAAQlB,EAAElD,IAAI,GAAG+D,KAAKI,QAAQd,EAAEH,EAAElD,GAAG+D,KAAKqB,OAAO,EAAEjC,CAAC,CAAzuMnD,qECoGnF,SAAS3C,EAAQC,EAAMC,EAAYC,QACf,IAAZA,IAAsBA,EAAU,CAAA,GACpC,IAAIC,EAAO,CAAEC,KAAM,WASnB,OARmB,IAAfF,EAAQG,IAAYH,EAAQG,MAC5BF,EAAKE,GAAKH,EAAQG,IAElBH,EAAQI,OACRH,EAAKG,KAAOJ,EAAQI,MAExBH,EAAKF,WAAaA,GAAc,CAAA,EAChCE,EAAKI,SAAWP,EACTG,CACX,CAoDA,SAASsD,EAAMhD,EAAaR,EAAYC,GAEpC,QADgB,IAAZA,IAAsBA,EAAU,CAAA,IAC/BO,EACD,MAAM,IAAI1B,MAAM,2BAEpB,IAAKkC,MAAMC,QAAQT,GACf,MAAM,IAAI1B,MAAM,gCAEpB,GAAI0B,EAAYC,OAAS,EACrB,MAAM,IAAI3B,MAAM,+CAEpB,IAAK+B,EAASL,EAAY,MAAQK,EAASL,EAAY,IACnD,MAAM,IAAI1B,MAAM,oCAMpB,OAAOgB,EAJI,CACPK,KAAM,QACNK,YAAaA,GAEIR,EAAYC,EACrC,CA4CA,SAASwD,EAAQjD,EAAaR,EAAYC,QACtB,IAAZA,IAAsBA,EAAU,CAAA,GACpC,IAAK,IAAIoJ,EAAK,EAAGC,EAAgB9I,EAAa6I,EAAKC,EAAc7I,OAAQ4I,IAAM,CAC3E,IAAInF,EAAOoF,EAAcD,GACzB,GAAInF,EAAKzD,OAAS,EACd,MAAM,IAAI3B,MAAM,+DAEpB,IAAK,IAAIwC,EAAI,EAAGA,EAAI4C,EAAKA,EAAKzD,OAAS,GAAGA,OAAQa,IAE9C,GAAI4C,EAAKA,EAAKzD,OAAS,GAAGa,KAAO4C,EAAK,GAAG5C,GACrC,MAAM,IAAIxC,MAAM,8CAGhC,CAKI,OAAOgB,EAJI,CACPK,KAAM,UACNK,YAAaA,GAEIR,EAAYC,EACrC,CA4CA,SAASM,EAAWC,EAAaR,EAAYC,GAEzC,QADgB,IAAZA,IAAsBA,EAAU,CAAA,GAChCO,EAAYC,OAAS,EACrB,MAAM,IAAI3B,MAAM,yDAMpB,OAAOgB,EAJI,CACPK,KAAM,aACNK,YAAaA,GAEIR,EAAYC,EACrC,CAkDA,SAASS,EAAkBC,EAAUV,QACjB,IAAZA,IAAsBA,EAAU,CAAA,GACpC,IAAIW,EAAK,CAAET,KAAM,qBAQjB,OAPIF,EAAQG,KACRQ,EAAGR,GAAKH,EAAQG,IAEhBH,EAAQI,OACRO,EAAGP,KAAOJ,EAAQI,MAEtBO,EAAGD,SAAWA,EACPC,CACX,CAmBA,SAAS2I,EAAgB/I,EAAaR,EAAYC,GAM9C,YALgB,IAAZA,IAAsBA,EAAU,CAAA,GAK7BH,EAJI,CACPK,KAAM,kBACNK,YAAaA,GAEIR,EAAYC,EACrC,CAmBA,SAASuJ,EAAWhJ,EAAaR,EAAYC,GAMzC,YALgB,IAAZA,IAAsBA,EAAU,CAAA,GAK7BH,EAJI,CACPK,KAAM,aACNK,YAAaA,GAEIR,EAAYC,EACrC,CAoBA,SAASwJ,EAAajJ,EAAaR,EAAYC,GAM3C,YALgB,IAAZA,IAAsBA,EAAU,CAAA,GAK7BH,EAJI,CACPK,KAAM,eACNK,YAAaA,GAEIR,EAAYC,EACrC,CA6DA,SAASyJ,EAAgBC,EAASC,QAChB,IAAVA,IAAoBA,EAAQ,cAChC,IAAIC,EAASC,EAAQC,QAAQH,GAC7B,IAAKC,EACD,MAAM,IAAI/K,MAAM8K,EAAQ,qBAE5B,OAAOD,EAAUE,CACrB,CAYA,SAASG,EAAgBC,EAAUL,QACjB,IAAVA,IAAoBA,EAAQ,cAChC,IAAIC,EAASC,EAAQC,QAAQH,GAC7B,IAAKC,EACD,MAAM,IAAI/K,MAAM8K,EAAQ,qBAE5B,OAAOK,EAAWJ,CACtB,CAuCA,SAASK,EAAiBP,GAEtB,OAAkB,KADJA,GAAW,EAAIlL,KAAKC,KACTD,KAAKC,EAClC,CAoEA,SAASmC,EAASC,GACd,OAAQC,MAAMD,IAAgB,OAARA,IAAiBE,MAAMC,QAAQH,EACzD,CA9nBAqJ,OAAOC,eAAcN,EAAU,aAAc,CAAEO,OAAO,IAUtDP,EAAAQ,YAAsB,UAOtBR,EAAAC,QAAkB,CACdQ,YAAmC,IAAtBT,EAAQQ,YACrBE,YAAmC,IAAtBV,EAAQQ,YACrBG,QAASX,EAAQQ,YAAc,OAC/BI,KAA4B,QAAtBZ,EAAQQ,YACdK,OAA8B,MAAtBb,EAAQQ,YAChBM,WAAYd,EAAQQ,YAAc,IAClCO,WAAYf,EAAQQ,YAAc,IAClCQ,OAAQhB,EAAQQ,YAChBS,OAAQjB,EAAQQ,YAChBU,MAAOlB,EAAQQ,YAAc,SAC7BW,YAAmC,IAAtBnB,EAAQQ,YACrBY,YAAmC,IAAtBpB,EAAQQ,YACrBa,cAAerB,EAAQQ,YAAc,KACrCX,QAAS,EACTyB,MAA6B,OAAtBtB,EAAQQ,aAQnBR,EAAAuB,aAAuB,CACnBd,YAAa,IACbC,YAAa,IACbC,QAAS,EAAI,OACbC,KAAM,QACNC,OAAQ,MACRC,WAAY,KACZC,WAAY,KACZC,OAAQ,EACRC,OAAQ,EACRC,MAAO,EAAI,SACXC,YAAa,IACbC,YAAa,IACbC,cAAe,EAAI,KACnBxB,QAAS,EAAIG,EAAQQ,YACrBc,MAAO,WAQXtB,EAAAwB,YAAsB,CAClBC,MAAO,UACPhB,YAAa,IACbC,YAAa,IACbE,KAAM,aACNc,SAAU,KACVb,OAAQ,eACRC,WAAY,KACZC,WAAY,KACZC,OAAQ,EACRC,OAAQ,EACRC,MAAO,OACPC,YAAa,IACbC,YAAa,IACbE,MAAO,aAmCXtB,EAAAhK,QAAkBA,EAmClBgK,EAAAxJ,SAnBA,SAAkBH,EAAMK,EAAaiL,GAEjC,OAAQtL,GACJ,IAAK,QACD,OAAOqD,EAAMhD,GAAaF,SAC9B,IAAK,aACD,OAAOC,EAAWC,GAAaF,SACnC,IAAK,UACD,OAAOmD,EAAQjD,GAAaF,SAChC,IAAK,aACD,OAAOkJ,EAAWhJ,GAAaF,SACnC,IAAK,kBACD,OAAOiJ,EAAgB/I,GAAaF,SACxC,IAAK,eACD,OAAOmJ,EAAajJ,GAAaF,SACrC,QACI,MAAM,IAAIxB,MAAMqB,EAAO,eAEnC,EAqCA2J,EAAAtG,MAAgBA,EA2BhBsG,EAAA4B,OANA,SAAgBlL,EAAaR,EAAYC,GAErC,YADgB,IAAZA,IAAsBA,EAAU,CAAA,GAC7BS,EAAkBF,EAAYmL,IAAI,SAAUjK,GAC/C,OAAO8B,EAAM9B,EAAQ1B,EAC7B,GAAQC,EACR,EAqCA6J,EAAArG,QAAkBA,EAyBlBqG,EAAA8B,SANA,SAAkBpL,EAAaR,EAAYC,GAEvC,YADgB,IAAZA,IAAsBA,EAAU,CAAA,GAC7BS,EAAkBF,EAAYmL,IAAI,SAAUjK,GAC/C,OAAO+B,EAAQ/B,EAAQ1B,EAC/B,GAAQC,EACR,EA8BA6J,EAAAvJ,WAAqBA,EA0BrBuJ,EAAA+B,YANA,SAAqBrL,EAAaR,EAAYC,GAE1C,YADgB,IAAZA,IAAsBA,EAAU,CAAA,GAC7BS,EAAkBF,EAAYmL,IAAI,SAAUjK,GAC/C,OAAOnB,EAAWmB,EAAQ1B,EAClC,GAAQC,EACR,EAoCA6J,EAAApJ,kBAA4BA,EA0B5BoJ,EAAAP,gBAA0BA,EA0B1BO,EAAAN,WAAqBA,EA2BrBM,EAAAL,aAAuBA,EA2BvBK,EAAAgC,mBARA,SAA4B3J,EAAYnC,EAAYC,GAMhD,YALgB,IAAZA,IAAsBA,EAAU,CAAA,GAK7BH,EAJI,CACPK,KAAM,qBACNgC,WAAYA,GAEKnC,EAAYC,EACrC,EAuBA6J,EAAAiC,MARA,SAAejL,EAAKkL,GAEhB,QADkB,IAAdA,IAAwBA,EAAY,GACpCA,KAAeA,GAAa,GAC5B,MAAM,IAAIlN,MAAM,uCAEpB,IAAImN,EAAaxN,KAAKW,IAAI,GAAI4M,GAAa,GAC3C,OAAOvN,KAAKsN,MAAMjL,EAAMmL,GAAcA,CAC1C,EAoBAnC,EAAAJ,gBAA0BA,EAmB1BI,EAAAE,gBAA0BA,EAc1BF,EAAAoC,gBAHA,SAAyBjC,EAAUL,GAC/B,OAAOM,EAAiBF,EAAgBC,EAAUL,GACtD,EAiBAE,EAAAqC,iBAPA,SAA0BC,GACtB,IAAIC,EAAQD,EAAU,IAItB,OAHIC,EAAQ,IACRA,GAAS,KAENA,CACX,EAaAvC,EAAAI,iBAA2BA,EAY3BJ,EAAAwC,iBAJA,SAA0B7B,GAEtB,OADcA,EAAU,IACNhM,KAAKC,GAAM,GACjC,EAmBAoL,EAAAyC,cARA,SAAuB9L,EAAQ+L,EAAcC,GAGzC,QAFqB,IAAjBD,IAA2BA,EAAe,mBAC5B,IAAdC,IAAwBA,EAAY,gBAClChM,GAAU,GACZ,MAAM,IAAI3B,MAAM,oCAEpB,OAAO4K,EAAgBM,EAAgBvJ,EAAQ+L,GAAeC,EAClE,EA0BA3C,EAAA4C,YAhBA,SAAqBC,EAAMH,EAAcC,GAGrC,QAFqB,IAAjBD,IAA2BA,EAAe,eAC5B,IAAdC,IAAwBA,EAAY,gBAClCE,GAAQ,GACV,MAAM,IAAI7N,MAAM,kCAEpB,IAAI8N,EAAc9C,EAAQwB,YAAYkB,GACtC,IAAKI,EACD,MAAM,IAAI9N,MAAM,0BAEpB,IAAI+N,EAAc/C,EAAQwB,YAAYmB,GACtC,IAAKI,EACD,MAAM,IAAI/N,MAAM,uBAEpB,OAAQ6N,EAAOC,EAAeC,CAClC,EAgBA/C,EAAAjJ,SAAmBA,EAenBiJ,EAAAgD,SAHA,SAAkBC,GACd,QAASA,GAASA,EAAMC,cAAgB7C,MAC5C,EAuCAL,EAAAmD,aAhBA,SAAsB5M,GAClB,IAAKA,EACD,MAAM,IAAIvB,MAAM,oBAEpB,IAAKkC,MAAMC,QAAQZ,GACf,MAAM,IAAIvB,MAAM,yBAEpB,GAAoB,IAAhBuB,EAAKI,QAAgC,IAAhBJ,EAAKI,OAC1B,MAAM,IAAI3B,MAAM,2CAEpBuB,EAAKsE,QAAQ,SAAU7D,GACnB,IAAKD,EAASC,GACV,MAAM,IAAIhC,MAAM,iCAE5B,EACA,EA+BAgL,EAAAoD,WARA,SAAoB9M,GAChB,IAAKA,EACD,MAAM,IAAItB,MAAM,kBAEpB,QAAI,CAAC,SAAU,UAAU+H,eAAezG,GACpC,MAAM,IAAItB,MAAM,kCAExB,mDChtBAqL,OAAOC,eAAe+C,EAAS,aAAc,CAAE9C,OAAO,IAEtD,IAAI+C,EAAUC,IAmCd,SAASnM,EAAUC,EAASC,EAAUC,GAEpC,GAAgB,OAAZF,EA4BJ,IA3BA,IAAIG,EACFC,EACAC,EACAlB,EACAmB,EACAC,EACAC,EAGAC,EAFAC,EAAa,EACbC,EAAa,EAEb3B,EAAOgB,EAAQhB,KACf4B,EAA+B,sBAAT5B,EACtB6B,EAAqB,YAAT7B,EACZ8B,EAAOF,EAAsBZ,EAAQR,SAASF,OAAS,EAchDyB,EAAe,EAAGA,EAAeD,EAAMC,IAAgB,CAS9DT,GAHAG,KALAD,EAA0BI,EACtBZ,EAAQR,SAASuB,GAAc5B,SAC/B0B,EACAb,EAAQb,SACRa,IAEiC,uBAAjCQ,EAAwBxB,MAGxBwB,EAAwBQ,WAAW1B,OACnC,EAEJ,IAAK,IAAI2B,EAAY,EAAGA,EAAYX,EAAOW,IAAa,CACtD,IAAIC,EAAoB,EACpBC,EAAgB,EAMpB,GAAiB,QALjBhC,EAAWsB,EACPD,EAAwBQ,WAAWC,GACnCT,GAGJ,CACAD,EAASpB,EAASE,YAClB,IAAI+B,EAAWjC,EAASH,KAQxB,OANA0B,GACER,GACc,YAAbkB,GAAuC,iBAAbA,EAEvB,EADA,EAGEA,GACN,KAAK,KACH,MACF,IAAK,QACH,IAOQ,IANNnB,EACEM,EACAI,EACAI,EACAG,EACAC,GAGF,OAAO,EACTR,IACAO,IACA,MACF,IAAK,aACL,IAAK,aACH,IAAKf,EAAI,EAAGA,EAAII,EAAOjB,OAAQa,IAAK,CAClC,IAOQ,IANNF,EACEM,EAAOJ,GACPQ,EACAI,EACAG,EACAC,GAGF,OAAO,EACTR,IACiB,eAAbS,GAA2BF,GAC3C,CAC2B,eAAbE,GAA2BF,IAC/B,MACF,IAAK,UACL,IAAK,kBACH,IAAKf,EAAI,EAAGA,EAAII,EAAOjB,OAAQa,IAAK,CAClC,IAAKC,EAAI,EAAGA,EAAIG,EAAOJ,GAAGb,OAASoB,EAAYN,IAAK,CAClD,IAOQ,IANNH,EACEM,EAAOJ,GAAGC,GACVO,EACAI,EACAG,EACAC,GAGF,OAAO,EACTR,GACd,CAC6B,oBAAbS,GAAgCF,IACnB,YAAbE,GAAwBD,GACxC,CAC2B,YAAbC,GAAwBF,IAC5B,MACF,IAAK,eACH,IAAKf,EAAI,EAAGA,EAAII,EAAOjB,OAAQa,IAAK,CAElC,IADAgB,EAAgB,EACXf,EAAI,EAAGA,EAAIG,EAAOJ,GAAGb,OAAQc,IAAK,CACrC,IAAKC,EAAI,EAAGA,EAAIE,EAAOJ,GAAGC,GAAGd,OAASoB,EAAYL,IAAK,CACrD,IAOQ,IANNJ,EACEM,EAAOJ,GAAGC,GAAGC,GACbM,EACAI,EACAG,EACAC,GAGF,OAAO,EACTR,GAChB,CACcQ,GACd,CACYD,GACZ,CACU,MACF,IAAK,qBACH,IAAKf,EAAI,EAAGA,EAAIhB,EAAS6B,WAAW1B,OAAQa,IAC1C,IAEE,IADAJ,EAAUZ,EAAS6B,WAAWb,GAAIF,EAAUC,GAG5C,OAAO,EACX,MACF,QACE,MAAM,IAAIvC,MAAM,yBAjGG,CAmG7B,CACA,CACA,CA0GA,SAASwO,EAASnM,EAASC,GACzB,IAAIqB,EACJ,OAAQtB,EAAQhB,MACd,IAAK,oBACH,IAAKsC,EAAI,EAAGA,EAAItB,EAAQR,SAASF,SACqB,IAAhDW,EAASD,EAAQR,SAAS8B,GAAGzC,WAAYyC,GADNA,KAGzC,MACF,IAAK,UACHrB,EAASD,EAAQnB,WAAY,GAGnC,CAoFA,SAASwC,EAAYrB,EAASC,GAC5B,GAAqB,YAAjBD,EAAQhB,KACViB,EAASD,EAAS,QACb,GAAqB,sBAAjBA,EAAQhB,KACjB,IAAK,IAAIsC,EAAI,EAAGA,EAAItB,EAAQR,SAASF,SACM,IAArCW,EAASD,EAAQR,SAAS8B,GAAIA,GADSA,KAIjD,CA6GA,SAASO,EAAS7B,EAASC,GACzB,IAAIqB,EACFnB,EACAqB,EACArC,EACAmB,EACAE,EACAC,EACAgB,EACAC,EACAC,EACAZ,EAAe,EACfH,EAAuC,sBAAjBZ,EAAQhB,KAC9B6B,EAA6B,YAAjBb,EAAQhB,KACpB8B,EAAOF,EAAsBZ,EAAQR,SAASF,OAAS,EAczD,IAAKgC,EAAI,EAAGA,EAAIR,EAAMQ,IAAK,CA4BzB,IA3BAd,EAA0BI,EACtBZ,EAAQR,SAAS8B,GAAGnC,SACpB0B,EACAb,EAAQb,SACRa,EACJyB,EAAoBb,EAChBZ,EAAQR,SAAS8B,GAAGzC,WACpBgC,EACAb,EAAQnB,WACR,CAAA,EACJ6C,EAAcd,EACVZ,EAAQR,SAAS8B,GAAGpC,KACpB2B,EACAb,EAAQd,UACR0C,EACJD,EAAYf,EACRZ,EAAQR,SAAS8B,GAAGrC,GACpB4B,EACAb,EAAQf,QACR2C,EAIJtB,GAHAG,IAAuBD,GACc,uBAAjCA,EAAwBxB,MAGxBwB,EAAwBQ,WAAW1B,OACnC,EAECkC,EAAI,EAAGA,EAAIlB,EAAOkB,IAMrB,GAAiB,QALjBrC,EAAWsB,EACPD,EAAwBQ,WAAWQ,GACnChB,GAgBJ,OAAQrB,EAASH,MACf,IAAK,QACL,IAAK,aACL,IAAK,aACL,IAAK,UACL,IAAK,kBACL,IAAK,eACH,IAOQ,IANNiB,EACEd,EACA4B,EACAU,EACAC,EACAC,GAGF,OAAO,EACT,MAEF,IAAK,qBACH,IAAKxB,EAAI,EAAGA,EAAIhB,EAAS6B,WAAW1B,OAAQa,IAC1C,IAOQ,IANNF,EACEd,EAAS6B,WAAWb,GACpBY,EACAU,EACAC,EACAC,GAGF,OAAO,EAEX,MAEF,QACE,MAAM,IAAIhE,MAAM,8BA/ClB,IAOQ,IANNsC,EACE,KACAc,EACAU,EACAC,EACAC,GAGF,OAAO,EA0CbZ,GACJ,CACA,CAyGA,SAASQ,EAAYvB,EAASC,GAC5B4B,EAAS7B,EAAS,SAAUb,EAAU4B,EAAclC,EAAYK,EAAMD,GAEpE,IAiBImC,EAjBApC,EAAoB,OAAbG,EAAoB,KAAOA,EAASH,KAC/C,OAAQA,GACN,KAAK,KACL,IAAK,QACL,IAAK,aACL,IAAK,UACH,OAKQ,IAJNiB,EACEgM,EAAQtN,QAAQQ,EAAUN,EAAY,CAAEK,KAAMA,EAAMD,GAAIA,IACxD8B,EACA,SAIJ,EAMJ,OAAQ/B,GACN,IAAK,aACHoC,EAAW,QACX,MACF,IAAK,kBACHA,EAAW,aACX,MACF,IAAK,eACHA,EAAW,UAIf,IACE,IAAIF,EAAoB,EACxBA,EAAoB/B,EAASE,YAAYC,OACzC4B,IACA,CACA,IACItC,EAAO,CACTI,KAAMoC,EACN/B,YAHeF,EAASE,YAAY6B,IAKtC,IAEE,IADAjB,EAASgM,EAAQtN,QAAQC,EAAMC,GAAakC,EAAcG,GAG1D,OAAO,CACf,CACA,EACA,CA0GA,SAASkL,EAAYpM,EAASC,GAC5BsB,EAAYvB,EAAS,SAAUrB,EAASoC,EAAcG,GACpD,IAAImL,EAAe,EAGnB,GAAK1N,EAAQQ,SAAb,CAEA,IAAIH,EAAOL,EAAQQ,SAASH,KAC5B,GAAa,UAATA,GAA6B,eAATA,EAAxB,CAGA,IAAI2E,EACA2I,EAAuB,EACvBC,EAAqB,EACrBC,EAAgB,EACpB,OAyCQ,IAxCNzM,EACEpB,EACA,SACE8N,EACA9L,EACA+L,EACAC,EACAxL,GAGA,QACqBS,IAAnB+B,GACA5C,EAAeuL,GACfK,EAAsBJ,GACtBpL,EAAgBqL,EAOhB,OALA7I,EAAiB8I,EACjBH,EAAuBvL,EACvBwL,EAAqBI,EACrBH,EAAgBrL,OAChBkL,EAAe,GAGjB,IAAIO,EAAiBX,EAAQ7M,WAC3B,CAACuE,EAAgB8I,GACjB9N,EAAQE,YAEV,IAOQ,IANNoB,EACE2M,EACA7L,EACAG,EACAC,EACAkL,GAGF,OAAO,EACTA,IACA1I,EAAiB8I,CAC3B,SAxCI,CAP+C,CAHxB,CAsD3B,EACA,CAkHA,SAASI,EAAS7M,EAASC,GAEzB,IAAKD,EAAS,MAAM,IAAIrC,MAAM,uBAE9B4D,EAAYvB,EAAS,SAAUrB,EAASoC,EAAcG,GACpD,GAAyB,OAArBvC,EAAQQ,SAAZ,CACA,IAAIH,EAAOL,EAAQQ,SAASH,KACxBuB,EAAS5B,EAAQQ,SAASE,YAC9B,OAAQL,GACN,IAAK,aACH,IAAiE,IAA7DiB,EAAStB,EAASoC,EAAcG,EAAmB,EAAG,GACxD,OAAO,EACT,MACF,IAAK,UACH,IACE,IAAIC,EAAgB,EACpBA,EAAgBZ,EAAOjB,OACvB6B,IAEA,IAMQ,IALNlB,EACEgM,EAAQ7M,WAAWmB,EAAOY,GAAgBxC,EAAQE,YAClDkC,EACAG,EACAC,GAGF,OAAO,EAtBgB,CA0BnC,EACA,QAqTA6K,EAAAc,SAt6BA,SAAkB9M,GAChB,IAAIO,EAAS,GAIb,OAHAR,EAAUC,EAAS,SAAUiC,GAC3B1B,EAAO6D,KAAKnC,EAChB,GACS1B,CACT,EAi6BAyL,EAAAjM,UAAoBA,EACpBiM,EAAAe,YA3oCA,SAAqB/M,EAASC,EAAU+M,EAAc9M,GACpD,IAAI+M,EAAgBD,EAwBpB,OAvBAjN,EACEC,EACA,SACEyM,EACA9L,EACAI,EACAG,EACAC,GAGE8L,EADiB,IAAftM,QAAqCiB,IAAjBoL,EACNP,EAEAxM,EACdgN,EACAR,EACA9L,EACAI,EACAG,EACAC,EAEV,EACIjB,GAEK+M,CACT,EAknCAjB,EAAA3K,YAAsBA,EACtB2K,EAAAkB,cAn8BA,SAAuBlN,EAASC,EAAU+M,GACxC,IAAIC,EAAgBD,EAMpB,OALA3L,EAAYrB,EAAS,SAAUmN,EAAgBpM,GAE3CkM,EADmB,IAAjBlM,QAAuCa,IAAjBoL,EACRG,EACGlN,EAASgN,EAAeE,EAAgBpM,EACjE,GACSkM,CACT,EA47BAjB,EAAAoB,UAnFA,SAAmBpN,EAASlB,GAG1B,GADAA,EAAUA,GAAW,CAAA,GAChBmN,EAAQN,SAAS7M,GAAU,MAAM,IAAInB,MAAM,sBAChD,IAOIwB,EAPA4B,EAAejC,EAAQiC,cAAgB,EACvCG,EAAoBpC,EAAQoC,mBAAqB,EACjDC,EAAgBrC,EAAQqC,eAAiB,EACzCR,EAAa7B,EAAQ6B,YAAc,EAGnC9B,EAAaC,EAAQD,WAGzB,OAAQmB,EAAQhB,MACd,IAAK,oBACC+B,EAAe,IACjBA,EAAef,EAAQR,SAASF,OAASyB,GAC3ClC,EAAaA,GAAcmB,EAAQR,SAASuB,GAAclC,WAC1DM,EAAWa,EAAQR,SAASuB,GAAc5B,SAC1C,MACF,IAAK,UACHN,EAAaA,GAAcmB,EAAQnB,WACnCM,EAAWa,EAAQb,SACnB,MACF,IAAK,QACL,IAAK,aACH,OAAO,KACT,IAAK,aACL,IAAK,UACL,IAAK,kBACL,IAAK,eACHA,EAAWa,EACX,MACF,QACE,MAAM,IAAIrC,MAAM,sBAIpB,GAAiB,OAAbwB,EAAmB,OAAO,KAC9B,IAAIoB,EAASpB,EAASE,YACtB,OAAQF,EAASH,MACf,IAAK,QACH,OAAOiN,EAAQ5J,MAAM9B,EAAQ1B,EAAYC,GAC3C,IAAK,aAGH,OAFIoC,EAAoB,IACtBA,EAAoBX,EAAOjB,OAAS4B,GAC/B+K,EAAQ5J,MAAM9B,EAAOW,GAAoBrC,EAAYC,GAC9D,IAAK,aAEH,OADI6B,EAAa,IAAGA,EAAaJ,EAAOjB,OAASqB,GAC1CsL,EAAQ5J,MAAM9B,EAAOI,GAAa9B,EAAYC,GACvD,IAAK,UAIH,OAHIqC,EAAgB,IAAGA,EAAgBZ,EAAOjB,OAAS6B,GACnDR,EAAa,IACfA,EAAaJ,EAAOY,GAAe7B,OAASqB,GACvCsL,EAAQ5J,MAAM9B,EAAOY,GAAeR,GAAa9B,EAAYC,GACtE,IAAK,kBAKH,OAJIoC,EAAoB,IACtBA,EAAoBX,EAAOjB,OAAS4B,GAClCP,EAAa,IACfA,EAAaJ,EAAOW,GAAmB5B,OAASqB,GAC3CsL,EAAQ5J,MAAM9B,EAAOW,GAAmBP,GAAa9B,EAAYC,GAC1E,IAAK,eAQH,OAPIoC,EAAoB,IACtBA,EAAoBX,EAAOjB,OAAS4B,GAClCC,EAAgB,IAClBA,EAAgBZ,EAAOW,GAAmB5B,OAAS6B,GACjDR,EAAa,IACfA,EACEJ,EAAOW,GAAmBC,GAAe7B,OAASqB,GAC/CsL,EAAQ5J,MACb9B,EAAOW,GAAmBC,GAAeR,GACzC9B,EACAC,GAGN,MAAM,IAAInB,MAAM,qBAClB,EAQAqO,EAAAqB,YArNA,SAAqBrN,EAASlB,GAG5B,GADAA,EAAUA,GAAW,CAAA,GAChBmN,EAAQN,SAAS7M,GAAU,MAAM,IAAInB,MAAM,sBAChD,IAOIwB,EAPA4B,EAAejC,EAAQiC,cAAgB,EACvCG,EAAoBpC,EAAQoC,mBAAqB,EACjDC,EAAgBrC,EAAQqC,eAAiB,EACzCkL,EAAevN,EAAQuN,cAAgB,EAGvCxN,EAAaC,EAAQD,WAGzB,OAAQmB,EAAQhB,MACd,IAAK,oBACC+B,EAAe,IACjBA,EAAef,EAAQR,SAASF,OAASyB,GAC3ClC,EAAaA,GAAcmB,EAAQR,SAASuB,GAAclC,WAC1DM,EAAWa,EAAQR,SAASuB,GAAc5B,SAC1C,MACF,IAAK,UACHN,EAAaA,GAAcmB,EAAQnB,WACnCM,EAAWa,EAAQb,SACnB,MACF,IAAK,QACL,IAAK,aACH,OAAO,KACT,IAAK,aACL,IAAK,UACL,IAAK,kBACL,IAAK,eACHA,EAAWa,EACX,MACF,QACE,MAAM,IAAIrC,MAAM,sBAIpB,GAAiB,OAAbwB,EAAmB,OAAO,KAC9B,IAAIoB,EAASpB,EAASE,YACtB,OAAQF,EAASH,MACf,IAAK,QACL,IAAK,aACH,OAAO,KACT,IAAK,aAEH,OADIqN,EAAe,IAAGA,EAAe9L,EAAOjB,OAAS+M,EAAe,GAC7DJ,EAAQ7M,WACb,CAACmB,EAAO8L,GAAe9L,EAAO8L,EAAe,IAC7CxN,EACAC,GAEJ,IAAK,UAIH,OAHIqC,EAAgB,IAAGA,EAAgBZ,EAAOjB,OAAS6B,GACnDkL,EAAe,IACjBA,EAAe9L,EAAOY,GAAe7B,OAAS+M,EAAe,GACxDJ,EAAQ7M,WACb,CACEmB,EAAOY,GAAekL,GACtB9L,EAAOY,GAAekL,EAAe,IAEvCxN,EACAC,GAEJ,IAAK,kBAKH,OAJIoC,EAAoB,IACtBA,EAAoBX,EAAOjB,OAAS4B,GAClCmL,EAAe,IACjBA,EAAe9L,EAAOW,GAAmB5B,OAAS+M,EAAe,GAC5DJ,EAAQ7M,WACb,CACEmB,EAAOW,GAAmBmL,GAC1B9L,EAAOW,GAAmBmL,EAAe,IAE3CxN,EACAC,GAEJ,IAAK,eAQH,OAPIoC,EAAoB,IACtBA,EAAoBX,EAAOjB,OAAS4B,GAClCC,EAAgB,IAClBA,EAAgBZ,EAAOW,GAAmB5B,OAAS6B,GACjDkL,EAAe,IACjBA,EACE9L,EAAOW,GAAmBC,GAAe7B,OAAS+M,EAAe,GAC9DJ,EAAQ7M,WACb,CACEmB,EAAOW,GAAmBC,GAAekL,GACzC9L,EAAOW,GAAmBC,GAAekL,EAAe,IAE1DxN,EACAC,GAGN,MAAM,IAAInB,MAAM,qBAClB,EAwHAqO,EAAAzK,YAAsBA,EACtByK,EAAAsB,cAvkBA,SAAuBtN,EAASC,EAAU+M,GACxC,IAAIC,EAAgBD,EAmBpB,OAlBAzL,EACEvB,EACA,SAAUmN,EAAgBpM,EAAcG,GAMpC+L,EAJiB,IAAjBlM,GACsB,IAAtBG,QACiBU,IAAjBoL,EAEgBG,EAEAlN,EACdgN,EACAE,EACApM,EACAG,EAEV,GAES+L,CACT,EAmjBAjB,EAAAnK,SAAmBA,EACnBmK,EAAAuB,WAluBA,SAAoBvN,EAASC,EAAU+M,GACrC,IAAIC,EAAgBD,EAuBpB,OAtBAnL,EACE7B,EACA,SACEwN,EACAzM,EACAU,EACAC,EACAC,GAGEsL,EADmB,IAAjBlM,QAAuCa,IAAjBoL,EACRQ,EAEAvN,EACdgN,EACAO,EACAzM,EACAU,EACAC,EACAC,EAEV,GAESsL,CACT,EA0sBAjB,EAAAa,SAAmBA,EACnBb,EAAAyB,WAjRA,SAAoBzN,EAASC,EAAU+M,GACrC,IAAIC,EAAgBD,EAgBpB,OAfAH,EACE7M,EACA,SAAU0N,EAAa3M,EAAcG,EAAmBC,GAEpD8L,EADmB,IAAjBlM,QAAuCa,IAAjBoL,EACRU,EAEAzN,EACdgN,EACAS,EACA3M,EACAG,EACAC,EAEV,GAES8L,CACT,EAgQAjB,EAAAG,SAAmBA,EACnBH,EAAA2B,WAviCA,SAAoB3N,EAASC,EAAU+M,GACrC,IAAIC,EAAgBD,EAOpB,OANAb,EAASnM,EAAS,SAAU4N,EAAmB7M,GAE3CkM,EADmB,IAAjBlM,QAAuCa,IAAjBoL,EACRY,EAEA3N,EAASgN,EAAeW,EAAmB7M,EACjE,GACSkM,CACT,EA+hCAjB,EAAAI,YAAsBA,EACtBJ,EAAA6B,cAhaA,SAAuB7N,EAASC,EAAU+M,GACxC,IAAIC,EAAgBD,EAChBc,GAAU,EAwBd,OAvBA1B,EACEpM,EACA,SACE4M,EACA7L,EACAG,EACAC,EACAkL,GAGEY,GADc,IAAZa,QAAsClM,IAAjBoL,EACPJ,EAEA3M,EACdgN,EACAL,EACA7L,EACAG,EACAC,EACAkL,GAEJyB,GAAU,CAChB,GAESb,CACT,gDCtgCAjE,OAAOC,eAAe+C,EAAS,aAAc,CAAE9C,OAAO,IACtD,IAAI6E,EAAS7B,IAeb,SAAShN,EAAKc,GACV,IAAI+B,EAAS,CAACC,IAAUA,KAAWA,KAAWA,KAe9C,OAdA+L,EAAOhO,UAAUC,EAAS,SAAUiC,GAC5BF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,IAElBF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,IAElBF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,IAElBF,EAAO,GAAKE,EAAM,KAClBF,EAAO,GAAKE,EAAM,GAE9B,GACWF,CACX,QACA7C,EAAc,QAAIA,EAClB8M,EAAAgC,QAAkB9O,+CCpClB,IAAI+O,EAAQ/B,IACRD,EAAUiC,IACVC,EAAOC,IACPC,EAAWC,IAAsBN,QACjC3M,EAAc8M,EAAK9M,YACP8M,EAAKpO,UACPkM,EAAQ3J,QACtB,IAAI/C,EAAoB0M,EAAQ1M,kBAahC,SAASgP,EAAaC,GAClB,IAAIC,EAAO,IAAIR,EAAMO,GAsLrB,OA5KAC,EAAK5H,OAAS,SAAUlI,GACpB,GAAqB,YAAjBA,EAAQK,KAAoB,MAAM,IAAIrB,MAAM,mBAEhD,OADAgB,EAAQO,KAAOP,EAAQO,KAAOP,EAAQO,KAAOmP,EAAS1P,GAC/CsP,EAAM5H,UAAUQ,OAAO6H,KAAKrJ,KAAM1G,EACjD,EAcI8P,EAAK7H,KAAO,SAAUpH,GAClB,IAAIoH,EAAO,GAgBX,OAdI/G,MAAMC,QAAQN,GACdA,EAASgE,QAAQ,SAAU7E,GACvB,GAAqB,YAAjBA,EAAQK,KAAoB,MAAM,IAAIrB,MAAM,oBAChDgB,EAAQO,KAAOP,EAAQO,KAAOP,EAAQO,KAAOmP,EAAS1P,GACtDiI,EAAKxC,KAAKzF,EAC1B,GAGY0C,EAAY7B,EAAU,SAAUb,GAC5B,GAAqB,YAAjBA,EAAQK,KAAoB,MAAM,IAAIrB,MAAM,oBAChDgB,EAAQO,KAAOP,EAAQO,KAAOP,EAAQO,KAAOmP,EAAS1P,GACtDiI,EAAKxC,KAAKzF,EAC1B,GAEesP,EAAM5H,UAAUO,KAAK8H,KAAKrJ,KAAMuB,EAC/C,EAaI6H,EAAKxH,OAAS,SAAUtI,EAASgQ,GAC7B,GAAqB,YAAjBhQ,EAAQK,KAAoB,MAAM,IAAIrB,MAAM,mBAEhD,OADAgB,EAAQO,KAAOP,EAAQO,KAAOP,EAAQO,KAAOmP,EAAS1P,GAC/CsP,EAAM5H,UAAUY,OAAOyH,KAAKrJ,KAAM1G,EAASgQ,EAC1D,EASIF,EAAKhJ,MAAQ,WACT,OAAOwI,EAAM5H,UAAUZ,MAAMiJ,KAAKrJ,KAC1C,EAYIoJ,EAAKhI,OAAS,SAAUzG,GACpB,IAAIR,EAAWyO,EAAM5H,UAAUI,OAAOiI,KAAKrJ,KAAMA,KAAKqB,OAAO1G,IAC7D,OAAOT,EAAkBC,EACjC,EAYIiP,EAAK9H,SAAW,SAAU3G,GACtB,OAAOiO,EAAM5H,UAAUM,SAAS+H,KAAKrJ,KAAMA,KAAKqB,OAAO1G,GAC/D,EASIyO,EAAKnI,IAAM,WACP,IAAI9G,EAAWyO,EAAM5H,UAAUC,IAAIoI,KAAKrJ,MACxC,OAAO9F,EAAkBC,EACjC,EASIiP,EAAKnH,OAAS,WACV,OAAO2G,EAAM5H,UAAUiB,OAAOoH,KAAKrJ,KAC3C,EA6BIoJ,EAAKlH,SAAW,SAAUqH,GACtB,OAAOX,EAAM5H,UAAUkB,SAASmH,KAAKrJ,KAAMuJ,EACnD,EASIH,EAAK/H,OAAS,SAAU1G,GACpB,IAAId,EACJ,GAAIc,EAAQd,KAAMA,EAAOc,EAAQd,UAC5B,GAAIW,MAAMC,QAAQE,IAA+B,IAAnBA,EAAQV,OAAcJ,EAAOc,OAC3D,GAAIH,MAAMC,QAAQE,IAA+B,IAAnBA,EAAQV,OAAcJ,EAAO,CAACc,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,GAAIA,EAAQ,SACxG,GAAqB,YAAjBA,EAAQhB,KAAoBE,EAAOmP,EAASrO,OAChD,IAAqB,sBAAjBA,EAAQhB,KACZ,MAAM,IAAIrB,MAAM,mBAD0BuB,EAAOmP,EAASrO,EACzB,CAEtC,MAAO,CACH4F,KAAM1G,EAAK,GACX2G,KAAM3G,EAAK,GACX4G,KAAM5G,EAAK,GACX6G,KAAM7G,EAAK,GAEvB,EACWuP,CACX,QAEAI,EAAAlG,QAAiB4F,EACjBM,EAAAlG,QAAAqF,QAAyBO,sBC3LzB,SAASO,EAAcC,EAAOC,GAC1B,IAAIC,EAAS,CAAA,EACT1L,EAAU,GASd,GANmB,eAAfwL,EAAM/P,OACN+P,EAAQpQ,EAAQoQ,IAED,eAAfC,EAAMhQ,OACNgQ,EAAQrQ,EAAQqQ,IAED,YAAfD,EAAM/P,MACS,YAAfgQ,EAAMhQ,MACa,OAAnB+P,EAAM5P,UACa,OAAnB6P,EAAM7P,UACkB,eAAxB4P,EAAM5P,SAASH,MACS,eAAxBgQ,EAAM7P,SAASH,MACuB,IAAtC+P,EAAM5P,SAASE,YAAYC,QACW,IAAtC0P,EAAM7P,SAASE,YAAYC,OAAc,CACzC,IAAI4P,EAAYC,EAAWJ,EAAOC,GAIlC,OAHIE,GACA3L,EAAQa,KAAK8K,GAEV3P,EAAkBgE,EAC7B,CAEA,IAAIkL,EAAOR,IAeX,OAdAQ,EAAK7H,KAAKtD,EAAY0L,IACtB3N,EAAYiC,EAAYyL,GAAQ,SAAU5K,GACtC9C,EAAYoN,EAAKhI,OAAOtC,GAAU,SAAUiL,GACxC,IAAIF,EAAYC,EAAWhL,EAASiL,GACpC,GAAIF,EAAW,CAEX,IAAIG,EAAMnN,EAAUgN,GAAWI,KAAK,KAC/BL,EAAOI,KACRJ,EAAOI,IAAO,EACd9L,EAAQa,KAAK8K,GAErB,CACJ,EACJ,GACO3P,EAAkBgE,EAC7B,CASA,SAAS4L,EAAWJ,EAAOC,GACvB,IAAInL,EAAU3B,EAAU6M,GACpBjL,EAAU5B,EAAU8M,GACxB,GAAuB,IAAnBnL,EAAQvE,OACR,MAAM,IAAI3B,MAAM,sDAEpB,GAAuB,IAAnBmG,EAAQxE,OACR,MAAM,IAAI3B,MAAM,sDAEpB,IAAIoG,EAAKF,EAAQ,GAAG,GAChBG,EAAKH,EAAQ,GAAG,GAChBI,EAAKJ,EAAQ,GAAG,GAChBK,EAAKL,EAAQ,GAAG,GAChB0L,EAAKzL,EAAQ,GAAG,GAChB0L,EAAK1L,EAAQ,GAAG,GAChB2L,EAAK3L,EAAQ,GAAG,GAChB4L,EAAK5L,EAAQ,GAAG,GAChB6L,GAASD,EAAKF,IAAOvL,EAAKF,IAAO0L,EAAKF,IAAOrL,EAAKF,GAClD4L,GAASH,EAAKF,IAAOvL,EAAKwL,IAAOE,EAAKF,IAAOzL,EAAKwL,GAClDM,GAAS5L,EAAKF,IAAOC,EAAKwL,IAAOtL,EAAKF,IAAOD,EAAKwL,GACtD,GAAc,IAAVI,EACA,OACW,KAIf,IAAIG,EAAKF,EAAQD,EACbI,EAAKF,EAAQF,EACjB,OAAIG,GAAM,GAAKA,GAAM,GAAKC,GAAM,GAAKA,GAAM,EX6DxC,SAAe1Q,EAAaR,EAAYC,GAE3C,QADgB,IAAZA,IAAsBA,EAAU,CAAA,IAC/BO,EACD,MAAM,IAAI1B,MAAM,2BAEpB,IAAKkC,MAAMC,QAAQT,GACf,MAAM,IAAI1B,MAAM,gCAEpB,GAAI0B,EAAYC,OAAS,EACrB,MAAM,IAAI3B,MAAM,+CAEpB,IAAK+B,EAASL,EAAY,MAAQK,EAASL,EAAY,IACnD,MAAM,IAAI1B,MAAM,oCAMpB,OAAOgB,EAJI,CACPK,KAAM,QACNK,YAAaA,GAEIR,EAAYC,EACrC,CW7EeuD,CAAM,CAFL0B,EAAK+L,GAAM7L,EAAKF,GAChBC,EAAK8L,GAAM5L,EAAKF,KAGrB,IACX,CCtFe,SAAAgM,EAAUC,EAAMnR,QACX,IAAZA,IAAsBA,EAAU,CAAA,GACpC,IAAIF,EAAOuD,EAAQ8N,GAInB,OAHKnR,EAAQD,YAA4B,YAAdoR,EAAKjR,OAC5BF,EAAQD,WAAaoR,EAAKpR,YAEtBD,EAAKI,MACT,IAAK,UACD,OAUL,SAAuBiR,EAAMnR,QAChB,IAAZA,IAAsBA,EAAU,CAAA,GACpC,IAAIF,EAAOuD,EAAQ8N,GACf1P,EAAS3B,EAAKS,YACdR,EAAaC,EAAQD,WACnBC,EAAQD,WACM,YAAdoR,EAAKjR,KACDiR,EAAKpR,WACL,CAAA,EACV,OAAOqR,EAAa3P,EAAQ1B,EAChC,CApBmBmR,CAAcpR,EAAME,GAC/B,IAAK,eACD,OAsBL,SAA4BqR,EAAWrR,QAC1B,IAAZA,IAAsBA,EAAU,CAAA,GACpC,IAAIF,EAAOuD,EAAQgO,GACf5P,EAAS3B,EAAKS,YACdR,EAAaC,EAAQD,WACnBC,EAAQD,WACW,YAAnBsR,EAAUnR,KACNmR,EAAUtR,WACV,CAAA,EACNuR,EAAQ,GAIZ,OAHA7P,EAAOiD,QAAQ,SAAUvB,GACrBmO,EAAMhM,KAAK8L,EAAajO,EAAOpD,GACnC,GACOU,EAAkB6Q,EAC7B,CApCmBC,CAAmBzR,EAAME,GACpC,QACI,MAAM,IAAInB,MAAM,gBAE5B,CAoCO,SAASuS,EAAa3P,EAAQ1B,GACjC,OAAI0B,EAAOjB,OAAS,EZ2SjB,SAAyBD,EAAaR,EAAYC,GAMrD,YALgB,IAAZA,IAAsBA,EAAU,CAAA,GAK7BH,EAJI,CACPK,KAAM,kBACNK,YAAaA,GAEIR,EAAYC,EACrC,CYjTesJ,CAAgB7H,EAAQ1B,GAE5BO,EAAWmB,EAAO,GAAI1B,EACjC,CCxDA,SAASyR,EAAgBC,EAAUC,GAC/B,IAAIC,GAAO,EASX,OARAlP,EAAYgP,EAAU,SAAUG,GAC5BnP,EAAYiP,EAAU,SAAUG,GAC5B,IAAa,IAATF,EACA,OAAO,EAEXA,EAaZ,SAAkBG,EAAOC,GACrB,OAAQD,EAAM5R,MACV,IAAK,QACD,OAAQ6R,EAAM7R,MACV,IAAK,QACD,OAyHG8R,EAzHmBF,EAAMvR,YAyHlB0R,EAzH+BF,EAAMxR,cA0HxDyR,EAAM,KAAOC,EAAM,IAAMD,EAAM,KAAOC,EAAM,IAzHvC,IAAK,aACD,OAAQC,EAAcH,EAAOD,GACjC,IAAK,UACD,OAAQxO,EAAsBwO,EAAOC,GAG7C,MACJ,IAAK,aACD,OAAQA,EAAM7R,MACV,IAAK,QACD,OAAQgS,EAAcJ,EAAOC,GACjC,IAAK,aACD,OA2BpB,SAAsBI,EAAaC,GAE/B,GADuBpC,EAAcmC,EAAaC,GAC7B1R,SAASF,OAAS,EACnC,OAAO,EAEX,OAAO,CACX,CAjC4B6R,CAAaP,EAAOC,GAChC,IAAK,UACD,OAAQO,EAAaP,EAAOD,GAGpC,MACJ,IAAK,UACD,OAAQC,EAAM7R,MACV,IAAK,QACD,OAAQoD,EAAsByO,EAAOD,GACzC,IAAK,aACD,OAAQQ,EAAaR,EAAOC,GAChC,IAAK,UACD,OA4CpB,SAAsBN,EAAUC,GAC5B,IAAK,IAAItI,EAAK,EAAGmJ,EAAKd,EAASlR,YAAY,GAAI6I,EAAKmJ,EAAG/R,OAAQ4I,IAAM,CAEjE,GAAI9F,EADSiP,EAAGnJ,GACkBsI,GAC9B,OAAO,CAEf,CACA,IAAK,IAAIc,EAAK,EAAGC,EAAKf,EAASnR,YAAY,GAAIiS,EAAKC,EAAGjS,OAAQgS,IAAM,CAEjE,GAAIlP,EADSmP,EAAGD,GACkBf,GAC9B,OAAO,CAEf,CACA,IAAIiB,EAAmB1C,EAAckB,EAAcO,GAAWP,EAAcQ,IAC5E,GAAIgB,EAAiBhS,SAASF,OAAS,EACnC,OAAO,EAEX,OAAO,CACX,CA9D4BmS,CAAaZ,EAAOD,IA+FhD,IAAuBE,EAAOC,EA5F1B,OAAO,CACX,CAhDmBW,CAAShB,EAASvR,SAAUwR,EAASxR,SAChD,EACJ,GACOsR,CACX,CA8CA,SAASO,EAAc5R,EAAYmD,GAC/B,IAAK,IAAIjB,EAAI,EAAGA,EAAIlC,EAAWC,YAAYC,OAAS,EAAGgC,IACnD,GAAIqQ,EAAqBvS,EAAWC,YAAYiC,GAAIlC,EAAWC,YAAYiC,EAAI,GAAIiB,EAAGlD,aAClF,OAAO,EAGf,OAAO,CACX,CAQA,SAAS+R,EAAa9O,EAASlD,GAC3B,IAAK,IAAI8I,EAAK,EAAGmJ,EAAKjS,EAAWC,YAAa6I,EAAKmJ,EAAG/R,OAAQ4I,IAAM,CAEhE,GAAI9F,EADQiP,EAAGnJ,GACkB5F,GAC7B,OAAO,CAEf,CAEA,OADuBwM,EAAc1P,EAAY4Q,EAAc1N,IAC1C9C,SAASF,OAAS,CAI3C,CA8BA,SAASqS,EAAqBC,EAAkBC,EAAgBtP,GAC5D,IAAIuP,EAAMvP,EAAG,GAAKqP,EAAiB,GAC/BG,EAAMxP,EAAG,GAAKqP,EAAiB,GAC/BI,EAAMH,EAAe,GAAKD,EAAiB,GAC3CK,EAAMJ,EAAe,GAAKD,EAAiB,GAE/C,OAAc,IADFE,EAAMG,EAAMF,EAAMC,IAI1B1U,KAAK4U,IAAIF,IAAQ1U,KAAK4U,IAAID,GACtBD,EAAM,EACCJ,EAAiB,IAAMrP,EAAG,IAAMA,EAAG,IAAMsP,EAAe,GAGxDA,EAAe,IAAMtP,EAAG,IAAMA,EAAG,IAAMqP,EAAiB,GAG9DK,EAAM,EACJL,EAAiB,IAAMrP,EAAG,IAAMA,EAAG,IAAMsP,EAAe,GAGxDA,EAAe,IAAMtP,EAAG,IAAMA,EAAG,IAAMqP,EAAiB,GAEvE,CC3Ie,SAASO,EAAkB5B,EAAUC,GAChD,IAAIC,GAAO,EASX,OARAlP,EAAYgP,EAAU,SAAUG,GAC5BnP,EAAYiP,EAAU,SAAUG,GAC5B,IAAa,IAATF,EACA,OAAO,EAEXA,GAAQH,EAAgBI,EAASvR,SAAUwR,EAASxR,SACxD,EACJ,GACOsR,CACX,CCzBA,MAAM2B,EAAM9U,KAAKC,GAAK,aAkCN8U,EAAYC,EAAanU,EAAaf,GACpD,IAAIK,EASN,SAA6B6U,EAAanU,EAAaf,GACrD,IAAImV,EAAMjV,KAAKiV,IAAIpU,EAAMiU,GACrBI,EAAKlV,KAAKW,IAAI,EAAGb,GACjBF,EAAIsV,GAAMF,EAAM,IAAM,IACtBnV,EAAIqV,GAAM,GAAM,IAAOlV,KAAKyH,KAAK,EAAIwN,IAAQ,EAAIA,IAAQjV,KAAKC,KAGlEL,GAAQsV,GACA,IAAGtV,GAAQsV,GACnB,MAAO,CAACtV,EAAGC,EAAGC,EAChB,CAnBaqV,CAAoBH,EAAKnU,EAAKf,GAGzC,OAFAK,EAAK,GAAKH,KAAK4H,MAAMzH,EAAK,IAC1BA,EAAK,GAAKH,KAAK4H,MAAMzH,EAAK,IACnBA,CACT,OC/BaiV,EAiBX,WAAA7G,CAAYD,EAA+C+G,GACzD,GAAqB,iBAAV/G,EAAoB,CAE7B,IAAIgH,EjB4BJ,SAA0BC,GAC9B,MAAMzD,EAAQyD,EAAIzD,MAAM,wCACxB,GAAKA,EAGL,MAAO,CACLhS,EAAG0V,SAAS1D,EAAM,GAAI,IACtBnS,EAAG6V,SAAS1D,EAAM,IAAM,IAAK,IAC7BlS,EAAG4V,SAAS1D,EAAM,GAAI,IACtBjS,EAAG2V,SAAS1D,EAAM,GAAI,IAE1B,CiBvCiB2D,CAAgBnH,ICtB3B,SAA4BoH,GAChC,GAAU,MAANA,EACF,MAAM,IAAIrV,MAAM,sCAGlB,IAAIsV,GAAY,EACZnO,EAAIkO,EAAGE,OASX,GANIpO,EAAEqO,WAAW,OACfF,GAAY,EACZnO,EAAIA,EAAE7B,MAAM,IAIG,IAAb6B,EAAExF,OACJ,MAAM,IAAI3B,MAAM,sCAIlB,IAAIgI,EAAW/H,IACXwV,EAA6B,KAEjC,IAAK,MAAMC,KAAMvO,EAAG,CAClB,MAAMwO,EAAMC,OAAOF,GAAM,EACzB,IAAKE,OAAOC,UAAUF,IAAQA,EAAM,GAAKA,GAAO3N,EAASrG,OACvD,MAAM,IAAI3B,MAAM,0BAA0B0V,uBAE5CD,EAAY,IAAKzN,EAAS2N,IAC1B3N,EAAW/H,EAAYwV,EACzB,CAEA,IAAKA,EAIH,MAAM,IAAIzV,MAAM,2CAQlB,OAJIsV,IACFG,EAAUnW,GAAKK,KAAK4U,IAAIkB,EAAUnW,IAG7BmW,CACT,CDvB2CK,CAAkB7H,GACvD,IAAIgH,EAIF,MAAM,IAAIjV,MAAM,iCAAiCiO,KAEnD,OALEvG,KAAKuN,KAAOA,OACZvN,KAAKqO,+BAKT,CAAO,GjBjCD,MADiBjW,EiBkCDmO,IjBjCD,MAAOnO,GAAQ,MAAOA,GAAQ,MAAOA,EiBoCxD,OAFA4H,KAAKuN,KAAOhH,OACZvG,KAAKqO,gCjBpCL,IAAqBjW,EiBuCrB4H,KAAKuN,KjBqEL,SAAwBhH,GAC5B,MAAMjC,OAA8B,IAAdiC,EAAM+H,IAAsB/H,EAAM+H,IAAM,EAC9D,GAAIhK,IAAU,UAA2BA,GAAM,SAE7C,MAAM,IAAIhM,MAAM,wDAElB,MAAMV,EAAIK,KAAK4H,MAAQ,GAAK0G,EAAM+G,KAAQhJ,YAGpCyI,EAAM9U,KAAKC,GAAK,IAChBgV,EAAMjV,KAAKiV,IAAI3G,EAAMzN,IAAMiU,GAC3BI,EAAK,GAAK5G,EAAM+G,KACtB,IAAIzV,EAAIsV,GAAM5G,EAAM1N,IAAM,IAAM,IAChC,MAAMf,EAAIqV,GAAM,GAAM,IAAOlV,KAAKyH,KAAK,EAAIwN,IAAQ,EAAIA,IAAQjV,KAAKC,IAMpE,OAHAL,GAAQsV,EACJtV,EAAI,IAAGA,GAAQsV,GAEZ,CACLvV,EAAGA,EACHC,EAAGI,KAAK4H,MAAMhI,GACdC,EAAGG,KAAK4H,MAAM/H,GACdC,EAAGwO,EAAM+G,KAEb,CiB9FkBiB,CAAc,IACrBhI,EACH+G,UAAuB,IAATA,EAAwBA,EArCzB,KAyCjBtN,KAAKqO,+BACP,CAIA,EAAAG,CAAGC,EAAa,GACd,OAAOzO,KAAK0O,KAAK,CAAC9W,EAAG6W,GACvB,CAEA,IAAAE,CAAKF,EAAa,GAChB,OAAOzO,KAAK0O,KAAK,CAAC9W,GAAI6W,GACxB,CAEA,KAAAG,CAAMH,EAAa,GACjB,OAAOzO,KAAK0O,KAAK,CAAC5W,EAAG2W,GACvB,CAEA,KAAAI,CAAMJ,EAAa,GACjB,OAAOzO,KAAK0O,KAAK,CAAC5W,GAAI2W,GACxB,CAEA,IAAAK,CAAKL,EAAa,GAChB,OAAOzO,KAAK0O,KAAK,CAAC7W,EAAG4W,GACvB,CAEA,IAAAM,CAAKN,EAAa,GAChB,OAAOzO,KAAK0O,KAAK,CAAC7W,GAAI4W,GACxB,CAEA,IAAAC,CAAKD,GACH,MAAMO,EAAW,IAAI3B,EAAMrN,KAAKuN,MAQhC,OAPAyB,EAASzB,KAAO9U,EAAe,CAC7BV,EAAGiX,EAASzB,KAAKxV,EACjBH,EAAGoX,EAASzB,KAAK3V,GAAK6W,EAAG7W,GAAK,GAC9BC,EAAGmX,EAASzB,KAAK1V,GAAK4W,EAAG5W,GAAK,GAC9BC,EAAGkX,EAASzB,KAAKzV,GAAK2W,EAAG3W,GAAK,KAEhCkX,EAASX,gCACFW,CACT,CAEA,MAAAC,CAAOC,GACL,MAAM7W,OAA2B,IAAX6W,EAA0B,EAAIlP,KAAKuN,KAAKxV,EAAImX,EAClE,OAAO,IAAI7B,EAAMlV,EAAU6H,KAAKuN,KAAMlV,GACxC,CAEA,QAAAiI,GACE,OAAO/H,EAAYyH,KAAKuN,MAAMpI,IAAK/M,GAAS,IAAIiV,EAAMjV,GACxD,CAMA,YAAA+W,GACE,MAAO,IAEH3W,EAAewH,KAAKuN,MACnB6B,OAAO,EAAErX,IAAEH,IAAEC,IAAEC,OAAO,IAAIC,KAAKH,KAAKC,KAAKC,MAAQkI,KAAKqP,SACtDlK,IAAK/M,GAAS,IAAIiV,EAAMjV,OAGzBI,EAAewH,KAAKwO,KAAKjB,MACxBpI,IAAK/M,GAAS,IAAIiV,EAAMjV,OAGzBI,EAAewH,KAAK2O,OAAOpB,MAC1BpI,IAAK/M,GAAS,IAAIiV,EAAMjV,IAG/B,CAKA,QAAAkX,CAASC,GACP,MAAMhW,EAAOyG,KAAKwP,YACZxS,EAAQ,CACZrD,KAAM,QACNK,YAAa,CAACuV,EAAS1W,IAAK0W,EAASzW,MAEjC+G,EAAQG,KAAKsO,IACbnO,EAAOhH,EAAS,IAAI6G,KAAKuN,KAAM3V,EAAGoI,KAAKuN,KAAK3V,EAAI,IACtD,OACE6X,EAAsBlW,EAAMyD,UACH,IAAjBuS,EAASjB,MAAwB,GACvCiB,EAASjB,KAAOzO,GAAS0P,EAASjB,IAAMnO,EAK9C,CAGA,SAAAqP,GACE,MAAOE,EAAIC,GAAMzW,EAAQ8G,KAAKuN,MAC9B,MAAO,CACL5T,KAAM,UACNK,YAAa,CACX,CACE,CAAC0V,EAAG7W,IAAK6W,EAAG5W,KACZ,CAAC4W,EAAG7W,IAAK8W,EAAG7W,KACZ,CAAC6W,EAAG9W,IAAK8W,EAAG7W,KACZ,CAAC6W,EAAG9W,IAAK6W,EAAG5W,KACZ,CAAC4W,EAAG7W,IAAK6W,EAAG5W,OAIpB,CAGA,UAAA8W,GACE,MAAOF,EAAIC,GAAMzW,EAAQ8G,KAAKuN,MACxB1N,EAAQ1G,EAAS6G,KAAKuN,MACtBpN,EAAOhH,EAAS,IAAI6G,KAAKuN,KAAM3V,EAAGoI,KAAKuN,KAAK3V,EAAI,IACtD,MAAO,CACL,CAAC8X,EAAG7W,IAAK6W,EAAG5W,IAAK+G,GACjB,CAAC6P,EAAG7W,IAAK8W,EAAG7W,IAAK+G,GACjB,CAAC8P,EAAG9W,IAAK8W,EAAG7W,IAAK+G,GACjB,CAAC8P,EAAG9W,IAAK6W,EAAG5W,IAAK+G,GACjB,CAAC6P,EAAG7W,IAAK6W,EAAG5W,IAAKqH,GACjB,CAACuP,EAAG7W,IAAK8W,EAAG7W,IAAKqH,GACjB,CAACwP,EAAG9W,IAAK8W,EAAG7W,IAAKqH,GACjB,CAACwP,EAAG9W,IAAK6W,EAAG5W,IAAKqH,GAErB,CAEA,mBAAO0P,CAAajW,EAAY0T,GAC9B,OAAO,IAAID,EAAMzT,EAAI0T,EACvB,CAEA,yBAAOwC,CAAmBC,EAAyBzC,GACjD,OAAO,IAAID,EAAM0C,EAAKzC,EACxB,CAEA,qBAAO0C,CAAeX,GACpB,OAAO,IAAIhC,EAAMgC,EACnB,CAGA,+BAAOY,CAAyB1W,EAAgB2W,GAC9CA,EAAUA,GAAW,GACrB,MACMC,ED3KJ,SAAqBC,EAAkBF,GAC3C,MAAM7W,EAAM2T,EAAYoD,EAAW,GAAIA,EAAW,GAAI,IAChDhX,EAAM4T,EAAYoD,EAAW,GAAIA,EAAW,GAAI,IAChDvW,EAAa,CAACR,EAAI,GAAIA,EAAI,GAAID,EAAI,GAAIA,EAAI,IAE1CrB,EAAIE,KAAKoB,IApBX,SAAsBQ,GAC1B,IAAK,IAAI9B,EAAI,EAAGA,EAHD,GAGeA,IAAK,CACjC,MAAMsY,EAAO,GAAM,IAAMtY,EAAI,GAC7B,IAAM8B,EAAK,GAAKwW,MAAWxW,EAAK,GAAKwW,KAC/BxW,EAAK,GAAKwW,MAAWxW,EAAK,GAAKwW,GACnC,OAAOtY,CAEX,CAEA,OAXe,EAYjB,CAUqBuY,CAAYzW,QAA0B,IAAZqW,EAA0BA,EAtBxD,IAuBf,OAAU,IAANnY,EAAgB,CAAC,EAAG,EAAG,GAGpB,CAFG8B,EAAK,KAAQ,GAAK9B,EAClB8B,EAAK,KAAQ,GAAK9B,EACdA,EAChB,CCiKwBwY,CADPvH,EAASzP,GACe2W,IAC7BrY,EAAGC,EAAGC,GAAMoY,EACpB,OAAO,IAAI9C,EAAM,CAACxV,IAAGC,IAAGC,IAAGH,EAAG,GAChC,CAGA,wBAAO4Y,CAAkBjX,EAAgB+T,GACvC,MAAMvV,EAAIuV,EAEV,GAAU,IAANvV,EAEF,MAAO,CAAC,IAAIsV,EAAM,YAGpB,GAAkB,uBAAd9T,EAAKI,KACP,MAAM,IAAIrB,MAAM,oCAIlB,MAAMuB,EAAOmP,EAASzP,GAChBF,EAAM2T,EAAYnT,EAAK,GAAIA,EAAK,GAAI,IACpCT,EAAM4T,EAAYnT,EAAK,GAAIA,EAAK,GAAI,IACpC0G,EAAQtI,KAAKoB,IAAIA,EAAI,GAAID,EAAI,MAAU,GAAKrB,EAC5CyI,EAAQvI,KAAKoB,IAAIA,EAAI,GAAID,EAAI,MAAU,GAAKrB,EAC5C0I,GAAQxI,KAAKmB,IAAIA,EAAI,GAAIC,EAAI,MAAS,GAAKtB,GAAM,EACjD2I,GAAQzI,KAAKmB,IAAIA,EAAI,GAAIC,EAAI,MAAS,GAAKtB,GAAM,EACjD0Y,EAAkB,GAGxB,IAAK,IAAI5Y,EAAI0I,EAAM1I,GAAK4I,EAAM5I,IAC5B,IAAK,IAAIC,EAAI0I,EAAM1I,GAAK4I,EAAM5I,IAAK,CACjC,MAAM4Y,EAAQ,IAAIrD,EAAM,CAACxV,IAAGC,IAAGC,IAAGH,EAAG,IACjC6X,EAAsBlW,EAAMmX,EAAMlB,cACpCiB,EAAO1R,KAAK2R,EAEhB,CAEF,OAAOD,CACT,CAEQ,6BAAApC,GjBjJJ,IAA6BjW,EiBkJ/B4H,KAAKsO,IAAMnV,EAAS6G,KAAKuN,MACzBvN,KAAK2Q,OjBlJA,IACF1X,EAF4Bb,EiBmJE4H,KAAKuN,MjBhJtCe,IAAKnV,EAASf,GAAS,SAA0B,IAAIA,EAAKL,EAAI,IiBiJ9DiI,KAAKsN,KAAOtN,KAAKuN,KAAKxV,EACtBiI,KAAKpG,GAAKoG,KAAK4Q,SChLb,SAA2BxY,GAC/B,IAAIR,EAAEA,EAACC,EAAEA,EAACC,EAAEA,EAACC,EAAEA,GAAMK,EACrB,MAAMyY,EAAYjZ,EAClB,IAAIkZ,EAAM,GAEV,KAAO/Y,EAAI,GAAG,CACZ,MACMkX,EAAS9W,EADY,CAAEP,EAAGK,KAAK4U,IAAIjV,GAAIC,IAAGC,IAAGC,MAI7CgZ,EAFmBxY,EAAY0W,GAEK+B,UACvCC,GACCA,EAAMrZ,IAAMK,KAAK4U,IAAIjV,IACrBqZ,EAAMpZ,IAAMA,GACZoZ,EAAMnZ,IAAMA,GACZmZ,EAAMlZ,IAAMA,GAGhB,GAAIgZ,EAAmB,EAErB,MAAM,IAAIzY,MAAM,gDAGlBwY,EAAMI,OAAOH,EAAmB,GAAKD,EAGrClZ,EAAIqX,EAAOrX,EACXC,EAAIoX,EAAOpX,EACXC,EAAImX,EAAOnX,EACXC,EAAIkX,EAAOlX,CACb,CAGA,OAAQ8Y,EAAY,EAAI,IAAM,IAAMC,CACtC,CD8I8BK,CAAiBnR,KAAKuN,MAChDvN,KAAKqP,QAAU,IAAIrP,KAAKuN,KAAKxV,KAAKiI,KAAKuN,KAAK3V,KAAKoI,KAAKuN,KAAK1V,KAAKmI,KAAKuN,KAAKzV,GAC5E","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}